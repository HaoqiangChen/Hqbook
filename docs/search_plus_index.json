{"./":{"url":"./","title":"介绍","keywords":"","body":" hqbook 介绍 学的不仅是技术，更是人生！ hqbook其实是我个人平时学习笔记，就是零散记点编程知识点。方便平时查阅。并且把hqbook利用GitHub / Git和Markdown 构建成精美的书籍。 作者 大家叫我小浩就OK啦，后面有必要我也会用小浩自称 本项目地址 仓库：https://github.com/HaoqiangChen/hqbook 在线阅读：https://haoqiangchen.github.io/hqbook/ Build Setup 克隆代码到本地之后，可以查看本书 Gitbook 笔记了解如何运行本项目。 # 如果 gitbook 没有安装，运行下面的命令，如果有，忽略它 npm install -g gitbook-cli # 安装依赖 gitbook install or npm install (推荐) # 启动服务和热更新并打开 \"localhost:4000\" gitbook serve # 打包压缩项目 gitbook build # \"gitbook serve\"时其实已经打包好到 _book 并运行项目的，所以可以省略打包步骤， # 直接将 _book 重命名为 docs，这样子可以直接构建部署到 GitHub pages， # 注意在 GitHub 上将项目设置里的 GitHub pages 网站构建选择为 \"master/branch /docs folder\" rename _book docs # 删除docs文件夹内所有md文件，避免GitHub pages构建失败 del /S /Q docs\\*.md 技术栈 HTML / CSS HTML HTML5 CSS CSS3 Bootstrap3：待记录 Font Awesome：待记录 Foundation：待记录 JavaScript JavaScript jQuery：待记录 AngularJS：待记录 Vue.js：待记录 React：待记录 服务端 Python：待记录 Linux：待记录 Docker：待记录 Ruby：待记录 Java：待记录 数据库 SQL：待记录 Mysql：待记录 PostgreSQL：待记录 SQLite：待记录 MongoDB：待记录 移动端 Android：待记录 Swift：待记录 jQuery Mobile：待记录 ionic：待记录 Kotlin：待记录 Web Service Web Service：待记录 WSDL：待记录 SOAP：待记录 RSS：待记录 RDF：待记录 开发工具 Gitbook Markdown Eclipse：待记录 Git：待记录 Svn：待记录 网站建设 HTTP：待记录 网站建设指南：待记录 浏览器信息：待记录 网站主机教程：待记录 TCP/IP：待记录 W3C：待记录 网站品质：待记录 其他 其他：待记录 最后 如果觉得我的笔记还不错的话 &#x1F44F; ，就给个star &#x1F31F; 鼓励一下吧~ "},"Tools/gitbook/":{"url":"Tools/gitbook/","title":"Gitbook","keywords":"","body":"Gitbook 使用教程 使用 Git 和 Markdown 制作精美在线电子书。 支持格式 GitBook支持输出多种文档格式，如： 静态站点：GitBook默认输出该种格式，生成的静态站点可直接托管搭载Github Pages服务上； PDF：需要安装ebook-concert依赖； eBook：需要安装ebook-concert； 单HTML网页：支持将内容输出为单页的HTML，不过一般用在将电子书格式转换为PDF或eBook的中间过程； JSON：一般用于电子书的调试或元数据提取。 Gitbook项目地址 GitBook项目官网：http://www.gitbook.io GitBook Github地址：https://github.com/GitbookIO/gitbook GitBook 文档中文版：http://gitbook.hushuang.me/setup.html 安装和使用GitBook 完成GitBook的安装只需要几分钟。 GitBook.com GitBook.com为您提供简单高效的图书在线撰写、发布和托管方案， 你可以通过GitBook.com进行在线编辑、或者使用GitBook 本地编辑器在本地电脑上编辑。 本地安装gitbook-cli 安装GitBook的最好方法是通过 NPM 安装。在已经安装好NodeJS和NPM的电脑上，通过命令行窗口，输入以下命令安装GitBook： $ npm install gitbook-cli -g 安装完成之后，你可以使用下面的命令来检验是否安装成功 $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 如果你看到了上面类似的版本信息，则表示你已经安装成功了。 安装其他版本 gitbook命令可以方便地下载和安装不同版本的GitBook来测试你的书： $ gitbook fetch 4.0.0-alpha.1 使用gitbook ls-remote列出可用于安装的远程版本。 $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.5, ...部分省略..., 4.0.0-alpha.1, 3.2.2, 3.2.1, ...部分省略..., 2.0.0-alpha.1 Tags: latest : 3.2.2 pre : 4.0.0-alpha.5 调试 您可以使用--log=debug和--debug来获得更详细的错误消息（堆栈跟踪）。例如： $ gitbook serve ./ --log=debug --debug or $ gitbook build ./ --log=debug --debug gitbook-cli命令行使用 gitbook-cli是一个命令行工具，使用方法： 初始化 初始化一本书 gitbook init 在使用 gitbook init 之后本地会生成两个文件 README.md 和 SUMMARY.md ，这两个文件都是必须的，一个为介绍，一个为目录结构。 编辑电子书 首先，GitBook使用SUMMARY.md文件组织整个内容的目录，比如可以新建 Faq.md 文件，来记录常见问题，并在 SUMMARY.md 文件中添加目录。 # Summary * [简介](build.md) * [常见问题](config.md) 本地预览 当内容书写完毕后，可以在终端中输入如下命令，实现实时预览 gitbook serve gitbook serve ./{book_name} gitbook serve 命令实际会先调用 gitbook build 编译书籍，完成后打开 web 服务器，默认监听本地 4000 端口，在浏览器打开 http://localhost:4000 即可浏览电子书。 [!danger] windows 系统上启动 gitbook 服务后,如果本地文件发生更改,热加载会失败。由于官方已经停止更新，所以找不到其他方法可以解决。小浩目前有个不是方法中的方法，如果启动服务器后立即删除 _book 目录,那么之后再怎么修改本地文件都能顺利重启。 发布电子书 gitbook build gitbook build ./{book_name} --output=./{outputFolde} gitbook build ./ --log=debug --debug 当电子书内容制作好之后，可以使用如下命令来生成 HTML 静态网页版电子书。该命令会在当前文件夹中生成 _book 文件夹，这个文件夹中的内容就是静态网页版电子书。 使用 --log=debug --debug 可以用来调试，会打印出 stack trace。 查看帮助 $ gitbook -h 目录结构 GitBook使用SUMMARY文件管理目录结构，文件支持Markdown和Asciidoc两种语法。 GitBook按照SUMMARY文件中的目录结构生成HTML。 如果你通过GitBook创建一本支持多语言文档，目录结构会稍微不同，具体可参考多语言环境。 一般GitBook目录如下： . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 简单的介绍下每个文件的作用： 文件 说明 book.json 保存 配置文件 数据 (可选) README.md 简介 - 书籍的简单介绍 (必填) SUMMARY.md 目录 (参见 目录管理) (可选) GLOSSARY.md 字段/注释 - 专业术语列表 (参见 词汇表) (可选) 静态文件和图像 静态文件是SUMMARY.md中没有列出的文件。所有的静态文件，除非被忽略文件和文件夹，否则都会被复制到输出中，包含图片、JS、CSS都会复制到对应目录下。 忽略文件和文件夹 GitBook将读取.gitignore、.bookignore和.ignore文件，以获取要忽略的文件和文件夹的列表。被忽略的文件不会被上传到版本中。 这些文件中的格式遵循与.gitignore相同的约定： ＃井号代表这是一行注释 ＃忽略文件test.md test.md ＃忽略目录“bin”中的所有内容 bin/* 以子目录的方式与项目集成 对于软件项目，您可以使用子目录（如docs/）来存储用于项目文档的书。您可以配置配置以指示GitBook可以在其中找到书籍文件的文件夹： . ├── book.json └── docs/ ├── README.md └── SUMMARY.md book.json 中的配置如下： { \"root\": \"./docs\" } 菜单与页面（Summary.md) Summary GitBook使用一个 SUMMARY.md 文件来定义文档的菜单。 SUMMARY.md中[]内的内容是标题，()内是文档的路径，章节和子章节用四个空格或者tab键来分级。 简单示例 # 概述 ### 第一部分 * [第一部分](part1/README.md) * [写作很好](part1/README.md＃writing) * [GitBook很不错](part1/README.md＃gitbook) * [第二部分](part2/README.md) * [我们喜欢社交网络](part2/README.md#feedback) * [更好的写作工具](part2/README.md#tools) 每一个章节都有一个专用的页面（part1/README.md#），并被分割成子章节。 锚点 文章可以使用区域导航定位到文件的特定部分。 在md文件结尾使用#号加上文章内容中章节的标题就能实现锚点 # 概述 ### 第一部分 * [第一部分](part1/README.md) * [写作很好](part1/README.md＃writing) * [GitBook很不错](part1/README.md＃gitbook) 部分 目录可以分为由标题或水平线分隔的部分： # 概述 ### 第一部分 * [ 写的很好 ]（part1 / writing.md） * [ GitBook的很好 ]（part1 / gitbook.md） ### 第二部分 * [ 我们喜欢反馈 ]（part2 / feedback_please.md） * [ 给作者的更好工具 ]（part2 / better_tools.md） ---- * [ 没有标题的最后一部分 ]（part3 / title.md） 部分仅是章节的组，没有专用页面，但是根据主题，它将显示在导航中。 页面 Markdown语法 默认情况下，GitBook的大多数文件都使用Markdown语法。GitBook从中推断出您页面的结构。使用的语法类似于GitHub Flavored Markdown语法。也可以选择AsciiDoc语法。 章节文件示例 ＃ 本章标题 这是一个很棒地介绍。 ## 第1节 Markdown将决定您**书的结构_most_ ## 第2节 ... 顶部描述 页面可以用它作为描述。 它使用YAML格式的风格，在三条虚线之间。 文档中也可以不写顶部描述。 [!Tip|label: 特别提示：] 在没有安装支持插件之前，不要在文件中使用，否则编译或者运行会失败。 这里有一个基本示例： --- description: This is a short description of my page --- # The content of my page ... 顶部描述的内容可以定义自己的变量，可以参考页面变量，以便您可以在模板中使用它们。 Markdown语法 Markdown是GitBook的默认解析器，本文档基本上都是Markdown语法编写的。当然，你也可以选择AsciiDoc语法来编写文档。 AsciiDoc 从·2.0.0·版本开始，GitBook接受AsciiDoc语法文件作为输入格式。 有关格式的更多信息，请参阅AsciiDoc语法快速参考。 跟markdown一样，GitBook可以从下的面文件来提取结构：README.adoc，SUMMARY.adoc，LANGS.adoc和GLOSSARY.adoc。 主题 GitBook默认使用theme-default 主题，从3.0.0版本开始，可以自定义主题。 [!Warning] 自定义主题可能会导致某些插件不能正常工作。 主题的结构 主题是包含模板和资源文件的插件。可以选择只对单独的模板进行替换，因为主题都从默认主题扩展。 文件夹 说明 _layouts 包含所有模板的主文件夹 _layouts/website/page.html 普通页面的模板 _layouts/ebook/page.html 在电子书生成期间正常页面的模板(PDF，ePub，Mobi) 自定义主题 你可以直接从已有的主题创建模板。模板将首先在书的_layouts文件夹中解析，然后在已安装的插件/主题中解析。 简单的扩展 如果你自定义主题的目的只是让不同的文档和书有不同的显示，你可以使用模板语法： {% extends template.self %} {% block body %} {{ super() }} ... 这将被添加到 \"body\" 块 {% endblock %} 完整的例子可参考主题API 。 发布主题 主题以theme-前缀插件方式发布，可参考(插件文档)。例如，主题awesome将从theme-awesome插件加载，然后从gitbook-plugin-theme-awesome NPM包加载。 "},"Tools/gitbook/config.html":{"url":"Tools/gitbook/config.html","title":"配置和插件","keywords":"","body":"配置 GitBook允许您使用灵活的配置来自定义您的书。这些选项在book.json文件中指定。对于不熟悉JSON语法的作者，您可以使用JSONlint之类的工具来验证语法。 常规设置 变量 说明 root 包含所有图书文件的根文件夹的路径，除了book.json structure 指定自述，摘要，词汇表等的路径。请参见结构段落. title 书的标题，默认值从README中提取。在GitBook.com上，此字段已预填。 description 您的图书说明，默认值从自述文件中提取。在GitBook.com上，此字段已预填。 author 作者姓名。在GitBook.com上，此字段已预填。 isbn 书的国际码ISBN language 图书语言的ISO代码 ，默认值是en direction 文本的方向。可以是rtl或ltr，默认值取决于language的值 gitbook GitBook的版本。使用SemVer规范并接受诸如“> = 3.0.0”的条件 其他属性设置 links: 在左侧导航栏添加链接信息 { \"links\": { \"sidebar\": { \"Home\": \"https://www.baidu.com\" } } } styles: 自定义页面样式， 默认情况下各generator对应的css文件 { \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 结构体 除了root变量，你可以告诉Gitbook Readme，Summary，Glossary，Languages的文件名(而不是使用默认名称，如README.md)。 这些文件必须在您的书的根(或每个语言书的根)。不接受诸如dir/MY_README.md之类的路径。 变量 说明 structure.readme 自述文件名（默认为README.md） structure.summary 摘要文件名（默认为SUMMARY.md） structure.glossary 词汇表文件名（默认为GLOSSARY.md） structure.languages 语言文件名（默认为LANGS.md） PDF选项 PDF输出可以使用book.json中的一组选项来定制： 变量 说明 pdf.pageNumbers 在每页底部添加页码（默认为true） pdf.fontSize 基本字体大小（默认为12） pdf.fontFamily 基本字体系列（默认为Arial） pdf.paperSize 纸张尺寸，选项为 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'legal', 'letter' (默认为 a4) pdf.margin.top 上边距 (默认为 56) pdf.margin.bottom 底边距 (默认为 56) pdf.margin.right 右边距 (默认为 62) pdf.margin.left 左边距 (默认为 62) 词汇表 您可以指定要显示为注释的术语及其相应的定义。 基于这些术语，GitBook在编译的时候会自动构建索引并在页面中突出显示这些术语。 GLOSSARY.md是一个h2标题的列表，以及一个描述段落： ## 条款 该术语的定义 ## 另一个名词 使用它的定义，它可以包含粗体文本 以及所有其他类型的内联标记... 多种语言 GitBook支持多种语言编写的书籍或者文档。 首先需要在根目录创建一个名为LANGS.md的文件，然后按照语言创建子目录： # Languages * [中文](zh/) * [English](en/) * [French](fr/) * [Español](es/) 每种语言的配置 每个语言(例如：en)目录中都可以有一个book.json来定义自己的配置，它将作为主配置的扩展。 唯一的例外是插件，插件是全局指定的，语言环境配置不能指定特定的插件。 Markdown语法 Markdown是GitBook的默认解析器，本文档基本上都是Markdown语法编写的。当然，你也可以选择AsciiDoc语法来编写文档。 AsciiDoc 从·2.0.0·版本开始，GitBook接受AsciiDoc语法文件作为输入格式。 有关格式的更多信息，请参阅AsciiDoc语法快速参考。 跟markdown一样，GitBook可以从下的面文件来提取结构：README.adoc，SUMMARY.adoc，LANGS.adoc和GLOSSARY.adoc。 插件 可以通过 Gitbook 的插件来扩展 Gitbook 的功能，现有的 Gitbook 插件能够实现数学公式，Google 统计，评论等等功能。 所有的插件都可以从 https://plugins.gitbook.com/ 获取。 变量 说明 plugins 要加载的插件列表 pluginsConfig 插件配置 安装插件 Gitbook 安装插件比较简单，需要在项目下添加 book.json 文件，然后在其中添加 { \"plugins\": [\"plugins1\", \"plugins2\"], \"pluginsConfig\": { \"plugins1\": {} } } 注册完插件之后，可以通过下面的命令来安装插件 gitbook install Gitbook默认自带5个插件 highlight：代码高亮，通常会使用 prism 来替换 search：导航栏查询功能（不支持中文），所以通常会使用 search-pro 来替换 sharing：右上角分享功能 font-settings：字体设置（最上方的\"A\"符号） livereload：为GitBook实时重新加载 [!Tip] 可以在插件名称前面加 - 去除自带插件，例如常用去除自带搜索 \"plugins\": [ \"-search\" ] 常用的插件 下面列举一些常用的gitbook插件，至于怎么加上自己开发的插件，这里就不多说了，感兴趣的可以看这篇中文文档。 用法：在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装（单独安装推荐NPM）npm install gitbook-plugin-插件名，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接） 修改页面样式 ad 在每个页面顶部和底部添加广告或任何自定义内容 ➡️ https://github.com/zhaoda/gitbook-plugin-ad Advanced Emoji 支持emoji表情 ➡️ https://github.com/codeclou/gitbook-plugin-advanced-emoji anchors 标题带有 github 样式的锚点 ➡️ https://github.com/rlmv/gitbook-plugin-anchors anchor-navigation 锚点导航 ➡️ https://github.com/yaneryou/gitbook-plugin-anchor-navigation anchor-navigation-ex 插件锚导航-EX ➡️ https://github.com/zq99299/gitbook-plugin-anchor-navigation-ex auto-scroll-table 表格滚动条(为避免表格过宽，增加滚动条) ➡️ https://www.jianshu.com/p/427b8bb066e6 autotheme 自动换肤插件(早中晚自动切换) ➡️ https://github.com/willin/gitbook-plugin-autotheme change_girls 可自动切换的背景 ➡️ https://github.com/zhenchao125/gitbook-plugin-change_girls custom-favicon 修改标题栏图标 ➡️ https://github.com/Bandwidth/gitbook-plugin-custom-favicon chapter-fold 左侧目录折叠 ➡️ https://github.com/ColinCollins/gitbook-plugin-chapter-fold expandable-chapters 收起或展开章节目录中的父节点 ➡️ https://github.com/DomainDrivenArchitecture/gitbook-plugin-expandable-chapters expandable-chapters-small 折叠侧边栏 ➡️ https://github.com/lookdczar/gitbook-plugin-expandable-chapters-small-auto [!note|label: 这三款目录折叠的区别是：] expandable-chapters-small 和 expandable-chapters 效果相同，唯一不同的是expandable-chapters这个插件的箭头粗；另外这两款只有点击箭头才能实现折叠扩展。不如【chapter-fold 左侧目录折叠】好用 editlink 顶部显示编辑此页 ➡️ https://github.com/zhaoda/gitbook-plugin-editlink emphasize 为文字加上底色 ➡️ https://github.com/GitbookIO/plugin-emphasize favicon 更改网站的 favicon.ico ➡️ https://github.com/menduo/gitbook-plugin-favicon flexible-alerts 将块引用转换为漂亮的警报 ➡️ https://github.com/zanfab/gitbook-plugin-flexible-alerts github-buttons 显示 github 仓库的star和fork按钮 ➡️ https://github.com/azu/gitbook-plugin-github-buttons hide-element 隐藏元素 ➡️ https://github.com/gonjay/gitbook-plugin-hide-element insert-logo 将logo插入到导航栏上方中 ➡️ https://github.com/matusnovak/gitbook-plugin-insert-logo localized-footer 为 Gitbook 每一个页面添加页脚 ➡️ https://github.com/noerw/gitbook-plugin-localized-footer#readme prism 基于 Prism 的代码高亮 ➡️ https://github.com/gaearon/gitbook-plugin-prism page-copyright 自定义页面页脚版权（内容多） ➡️ https://github.com/skyFi/gitbook-plugin-page-footer splitter 在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度 ➡️ https://github.com/yoshidax/gitbook-plugin-splitter styles-sass 使用 SASS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-sass styles-less 使用 LESS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-less sectionx 分离各个段落，并提供一个展开收起的按钮 ➡️ https://github.com/ymcatar/gitbook-plugin-sectionx tbfed-pagefooter 自定义页脚，显示版权和最后修订时间 ➡️ https://github.com/zhj3618/gitbook-plugin-tbfed-pagefooter theme-fexa 基于gitbook主题机制定制的主题 ➡️ https://github.com/tonyyls/gitbook-plugin-theme-fexa 功能增强 ace 插入代码高亮编辑器 ➡️ https://github.com/ymcatar/gitbook-plugin-ace atoc 插入 TOC 目录 ➡️ https://github.com/willin/gitbook-plugin-atoc accordion 手风琴，可以实现将内容隐藏起来 ➡️ https://github.com/artalar/gitbook-plugin-accordion back-to-top-button 回到顶部 ➡️ https://github.com/stuebersystems/gitbook-plugin-back-to-top-button book-summary-scroll-position-saver 自动保存左侧目录区域导航条的位置 ➡️ https://github.com/yoshidax/gitbook-plugin-book-summary-scroll-position-saver baidu 使用百度统计 ➡️ https://github.com/poppinlp/gitbook-plugin-baidu click-reveal 默认隐藏，点击可显示。 ➡️ https://github.com/c4software/gitbook-plugin-click-reveal code 代码添加行号&复制按钮 ➡️ https://github.com/davidmogar/gitbook-plugin-code copy-code-button 为代码块添加复制的按钮 ➡️ https://github.com/WebEngage/gitbook-plugin-copy-code-button chart 使用 C3.js 图表 ➡️ https://github.com/csbun/gitbook-plugin-chart Donate Gitbook 捐赠打赏插件 ➡️ https://github.com/willin/gitbook-plugin-donate disqus 添加 disqus 评论插件 ➡️ https://github.com/GitbookIO/plugin-disqus duoshuo 使用多说评论 ➡️ https://github.com/codepiano/gitbook-plugin-duoshuo ga 添加 Google 统计代码 ➡️ https://github.com/GitbookIO/plugin-ga include-codeblock 通过引用文件插入代码 ➡️ https://github.com/azu/gitbook-plugin-include-codeblock jsfiddle 插入 JSFiddle 组件 ➡️ https://github.com/Mavrin/gitbook-plugin-jsfiddle jsbin 插入 JSBin 组件 ➡️ https://github.com/jcouyang/gitbook-plugin-jsbin mygitalk 基于gitalk的评论插件 ➡️ https://github.com/snowdreams1006/gitbook-plugin-mygitalk search-plus 支持中文搜索插件 ➡️ https://github.com/lwdgit/gitbook-plugin-search-plus search-pro 高级搜索（支持中文） ➡️ https://github.com/gitbook-plugins/gitbook-plugin-search-pro sitemap 生成站点地图 ➡️ https://github.com/GitbookIO/plugin-sitemap theme-api 编写 API 文档 ➡️ https://github.com/GitbookIO/theme-api mcqx 交互式多选插件 ➡️ https://github.com/ymcatar/gitbook-plugin-mcqx spoiler 隐藏答案，当鼠标划过时才显示 ➡️ https://github.com/ymcatar/gitbook-plugin-spoiler redirect 重定向页面跳转 ➡️ https://github.com/ketan/gitbook-plugin-redirect page-treeview 生成页内目录 ➡️ https://github.com/aleen42/gitbook-treeview simple-page-toc 生成本页目录 ➡️ https://github.com/stuebersystems/gitbook-plugin-simple-page-toc page-toc-button 悬浮目录 ➡️ https://github.com/stuebersystems/gitbook-plugin-page-toc-button Puml 使用 PlantUML 展示 uml 图 ➡️ https://github.com/GitbookIO/plugin-puml klipse 嵌入类似IDE的功能,可在代码段中实时交互，即（输入代码 > 执行结果 ➡️ https://github.com/brian-dawn/gitbook-plugin-klipse Todo 添加 Todo 功能 ➡️ https://github.com/ly-tools/gitbook-plugin-todo include-csv 展示 csv 文件内容 ➡️ https://github.com/TakuroFukamizu/gitbook-plugin-include-csv musicxml 支持 musicxml 格式的乐谱渲染 ➡️ https://github.com/ymcatar/gitbook-plugin-musicxml versions-select 添加版本选择的下拉菜单，针对文档有多个版本的情况 ➡️ https://github.com/prescottprue/gitbook-plugin-versions-select rss 添加 rss 订阅功能 ➡️ https://github.com/denysdovhan/gitbook-plugin-rss multipart 将书籍分成几个部分 ➡️ https://github.com/citizenmatt/gitbook-plugin-multipart url-embed 嵌入动态内容 ➡️ https://github.com/basilvetas/gitbook-plugin-url-embed pageview-count 阅读量计数 ➡️ https://github.com/tinys/gitbook-plugin-pageview-count 查看图片 image-captions 抓取内容中图片的alt或title属性，在图片下面显示标题 ➡️ https://github.com/todvora/gitbook-plugin-image-captions popup 单击图片，在新页面查看大图。 ➡️ https://github.com/somax/gitbook-plugin-popup lightbox 点击图片可显示，大小不变 ➡️ https://github.com/vongola12324/gitbook-plugin-lightbox 数学插件 & Tex fbqx 使用填空题 ➡️ https://github.com/Erwin-Chan/gitbook-plugin-fbqx Graph 使用 function-plot 绘制数学函数图 ➡️ https://github.com/cjam/gitbook-plugin-graph katex 使用KaTex进行数学排版 ➡️ https://github.com/GitbookIO/plugin-katex latex-codecogs 使用数学方程式 ➡️ https://github.com/GitbookIO/plugin-latex-codecogs mathjax 支持数学方程式 ➡️ https://www.mathjax.org/ mermaid 使用流程图 ➡️ https://github.com/JozoVilcek/gitbook-plugin-mermaid [!note|label: MathJax 和 KaTeX 的区别] mathjax 和 katex 插件是 Tex 公式绘制的不同实现，它们基于各自的开源库：KaTeX 和 MathJax 。MathJax 支持整个 Tex 语法，但是在制作电子书版本时不是很完美。 KaTex 在所有格式（网页和电子书）的绘制上都很完美，但是还不支持 所有的语法。 更多其他插件选择 https://www.cnblogs.com/mingyue5826/p/10307051.html https://www.jianshu.com/p/53fccf623f1c https://www.jianshu.com/p/427b8bb066e6 book.json配置（直接用本书配置来说明） { \"title\": \"hqbook\", \"author\": \"Haoqiang Chen\", \"description\": \"平时零散编程笔记收录手册，以便日后查阅。\", \"keywords\": \"编程,markdown,笔记\", \"introduction\": { \"path\": \"README.md\", \"title\": \"hqbook\" }, \"links\": { \"home\": false, \"about\": false, \"issues\": false, \"contribute\": false, \"tail\": { \"GitHub地址\": \"https://github.com/HaoqiangChen/hqbook\" }, \"gitbook\": false, \"sharing\": { \"google\": true, \"facebook\": true, \"twitter\": true, \"weibo\": true, \"qrcode\": true } }, \"variables\": { \"themeColor\": \"#3884ff\", \"themeHqbook\": { \"nav\": [ { \"url\": \"https://www.baidu.com\", \"target\": \"_blank\", \"name\": \"百度一下\" }, { \"url\": \"https://jsrun.net/\", \"target\": \"_blank\", \"name\": \"JSRUN\" }, { \"url\": \"https://www.runoob.com/\", \"target\": \"_blank\", \"name\": \"菜鸟教程\" }, { \"url\": \"https://www.atool99.com/\", \"target\": \"_blank\", \"name\": \"ATOOL在线工具\" } ] } }, \"plugins\": [ \"-highlight\", \"-lunr\", \"-search\", \"theme-hqbook\", \"chapter-fold\", \"flexible-alerts\", \"prism\", \"search-pro\", \"sitemap\" ], \"pluginsConfig\": { \"fontSettings\": { \"theme\": \"white\", \"family\": \"serif\", \"size\": 1 }, \"chapter-fold\": {}, \"flexible-alerts\": { \"style\": \"flat\", \"note\": { \"label\": \"笔记\" }, \"tip\": { \"label\": \"提示\" }, \"warning\": { \"label\": \"警告\", \"icon\": \"fa fa-warning\" }, \"danger\": { \"label\": \"注意\", \"icon\": \"fa fa-exclamation-triangle\" } }, \"localized-footer\": { \"hline\": true, \"filename\": \"./FOOTER.md\" }, \"prism\": { \"css\": [ \"gitbook-plugin-theme-hqbook/_themes/prism-xonokai.css\" ] }, \"styles\": { \"website\": \"styles/website.css\" }, \"theme-hqbook\": { \"copyLines\": false, \"hide-elements\": [ \".summary .gitbook-link\" ], \"flexible-linkcard\": { \"title\": \"Converts blockquotes into beautiful linkcard, custom nice links\", \"hrefUrl\": \"https://github.com/HaoqiangChen/hqbook\", \"imgSrc\": \"../../images/home/logo.png\" } }, \"sitemap\": { \"hostname\": \"https://haoqiangchen.github.io/hqbook/\" } }, \"pdf\": { \"toc\": true, \"pageNumbers\": true, \"fontSize\": 12, \"paperSize\": \"a4\", \"margin\": { \"right\": 62, \"left\": 62, \"top\": 36, \"bottom\": 36 } } } "},"Tools/gitbook/templating.html":{"url":"Tools/gitbook/templating.html","title":"模板","keywords":"","body":"模板 GitBook使用Nunjucks模板语言来处理页面和主题的模板。 Nunjucks语法与Jinja2或Liquid非常相似。语法使用大括号{}来标记需要处理的内容。 变量 变量从模板上下文中查找值。如果你想简单地显示一个变量，你可以使用{{variable}}语法。例如 ： 我的名字是{{ name }}，很高兴见到你 它从上下文中查找用户名并显示它。变量名称在其中可以有点像查找属性，就像JavaScript。您还可以使用方括号语法。 {{ foo.bar }} {{ foo[\"bar\"] }} 如果值未定义，则不显示任何内容。如果foo未定义，下面的所有输出都不会输出：{{ foo }}, {{ foo.bar }}, {{ foo.bar.baz }}。 GitBook提供了预定义变量。 过滤器 过滤器本质上是可以应用于变量的函数。它们用管道操作符(|)调用，并且可以接受参数。 {{ foo | title }} {{ foo | join(\",\") }} {{ foo | replace(\"foo\", \"bar\") | capitalize }} 第三个示例显示了如何链接过滤器。首先将“ foo”替换为“ bar”，然后将其大写，从而显示“ Bar”。 标签 if if 根据条件选择显示内容。它的行为与JavaScript的if行为完全一样。 {% if variable %} It is true {% endif %} 如果变量被定义并且计算结果为true，将显示“It is true”。否则，什么都不会显示。 您可以使用elif和else指定替代条件： {% if hungry %} I am hungry {% elif tired %} I am tired {% else %} I am good! {% endif %} for for 遍历数组和对象。 # Chapters about GitBook {% for article in glossary.terms['gitbook'].articles %} * [{{ article.title }}]({{ article.path }}) {% endfor %} set set 允许你创建/修改一个变量。 {% set softwareVersion = \"1.0.0\" %} Current version is {{ softwareVersion }}. [Download it](website.com/download/{{ softwareVersion }}) 转义 如果您希望GitBook忽略任何特殊的模板标签，则可以使用raw，并且其中的任何内容都将以纯文本格式输出。 {% raw %} this will {{ not be processed }} {% endraw %} 内容引用 内容引用（conref）是一种方便的机制，可以重用其他文件或书籍中的内容。 导入本地文件 使用include标签可以轻松导入其他文件的内容： {% include \"./test.md\" %} 从另一本书导入文件 GitBook还可以使用git解析包含路径： {% include \"git+https://github.com/GitbookIO/documentation.git/README.md#0.0.1\" %} git url的格式为： git+https://user@hostname/owner/project.git/file#commit-ish 真正的git url部分应该用.git结尾，导入的文件名在.git之后被提取，直到url的片段。 commit-ish是引用项目的分支。默认为master。 继承 模板继承是一种方便重用的方法。在编写模板时，定义子模板可以覆盖父模板的\"blocks\"。 block定义模板上的一个部分，并用一个名字来标识它。基本模板可以指定块，子模板可以用新内容覆盖它们。 {% extends \"./mypage.md\" %} {% block pageContent %} # This is my page content {% endblock %} 在mypage.md中，你应该指定可以扩展的块： {% block pageContent %} This is the default content {% endblock %} # License {% include \"./LICENSE\" %} 变量 以下是书的解析和主题生成期间可用数据的参考。 全局变量 变量 说明 book book.json的全书信息+配置设置。详情请参阅下文。 gitbook GitBook特定信息 page 当前页特定信息 file 与当前页特定信息相关联的文件 readme 自述相关内容 glossary 词汇相关内容 summary 菜单相关内容 languages 多语言书籍列表 output 输出相关内容 config book.json相关内容 书本变量 变量 说明 book.[CONFIGURATION_DATA] 在book.json中的variables下的所有其他值都可以在这里访问 book.language 多语言书的当前语言 例如，这个book.json： { variables: { hello: \"everyone\" } } ...下面的文本 {{ book.hello }} 将会展开为 everyone。 GitBook变量 变量 说明 gitbook.time 当前时间(当你运行gitbook命令时)。 gitbook.version GitBook用于生成图书的版本 文件变量 变量 说明 file.path 原始页面的路径 file.mtime 修改时间。上次修改文件的时间 file.type 用于编译此文件的语法解析器的名称(例如：markdown，asciidoc等) 页面变量 变量 说明 page.title 页面标题 page.previous 内容页的上一页(可以是null) page.next 内容页的下一页 (可以是null) page.dir 文本方向，基于配置(rtl或ltr) 目录变量 变量 说明 summary.parts 内容列表 可以访问整个目录(SUMMARY.md)： summary.parts[0].articles[0].title 将返回第一篇文章的标题。 多语言环境变量 变量 说明 languages.list 本书的语言环境列表 定义一种语言的方式：{ id: 'en', title: 'English' }. 输出变量 变量 说明 output.name 输出生成器的名称，可能的值是website, json, ebook output.format 当 output.name == \"ebook\", format 定义了将要生成的电子书的格式，可能的值是 pdf, epub 或 mobi 自述文件变量 变量 说明 readme.path 自述文件的路径 词汇表变量 变量 说明 glossary.path 词汇表的路径 模板助手 GitBook提供了一个内置过滤器和块来帮助您编写模板。 过滤器 value|default(default, [boolean]) 值如果未定义，则返回默认值，否则返回值。 如果boolean为true，任何JavaScript falsy值将返回默认值 (false, \"\", etc) arr|sort(reverse, caseSens, attr) 使用JavaScript的arr.sort函数排序数组。 如果reverse为true，则结果将被反转。 默认情况下，排序不区分大小写，但将caseSens设置为true会使它区分大小写。 最后会比较数组中每个元素的的大小。 块 {% markdown %}Markdown string{% endmarkdown %}渲染内联markdown {% asciidoc %}AsciiDoc string{% endasciidoc %}渲染内联asciidoc "},"Tools/gitbook/build.html":{"url":"Tools/gitbook/build.html","title":"打包和发布","keywords":"","body":"Gitbook 打包输出 输出为静态网站 你有两种方式输出一个静态的网站： 本地预览是自动生成 当你编辑好 gitbook 文档之后，你可以使用 gitbook 的命令来进行本地预览。 $ gitbook serve ./{book_name} gitbook会启动一个4000端口用于预览。 比如，通过gitbook serve来预览本文档： $ gitbook serve gitbook-howtouse Press CTRL+C to quit ... Live reload server started on port: 35729 Starting build ... Successfully built! Starting server ... Serving book on http://localhost:4000 你可以你的浏览器中打开这个网址： http://localhost:4000 你会发现，在你编辑的gitbook项目的目录中会多一个_book目录，而这个目录中就是生成的本地预览的静态网站内容。 使用gitbook build参数 与直接预览生成的静态网站不一样的时，使用这个命令，你可以将内容输出到你想要的目录。如果不使用 --output 参数则默认在当前文件夹下 $ gitbook build --output=/tmp/gitbook Starting build ... Successfuly built ! $ ls /tmp/gitbook/ howtouse search_index.json book imgs output gitbook index.html publish 无论哪种方式，你都可以将这个静态网站打包，发布到你想要发布的服务器上，或者直接将这个打包文件给阅读者。 生成电子书和PDF GitBook不仅可以生成静态网站，也可以将内容输出为电子书(ePub，Mobi，PDF)格式。 ＃生成PDF文件 $ gitbook pdf ./ ./mybook.pdf ＃生成ePub文件 $ gitbook epub ./ ./mybook.epub ＃生成Mobi文件 $ gitbook mobi ./ ./mybook.mobi 安装ebook-convert ebook-convert 是生成电子书所必需的(epub，mobi，pdf)插件。 Linux系统 安装Caliber应用程序。 $ sudo aptitude install calibre 在某些Linux发行版中安装nodejs，您还需要手动创建一个nodejs软链接： $sudo ln -s /usr/bin/nodejs /usr/bin/node 苹果OS X系统 下载Caliber应用程序。将calibre.app移动到您的应用程序文件夹后，创建一个指向ebook-convert工具的软件链接： $ sudo ln -s ~/Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin 这样就可以在任何目录下执行目录执行ebook-convert命令。 如果出现Operation not permitted异常，说明系统权限限制，需要配置环境变量的方式解决 $ sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin ln: /usr/bin/ebook-convert: Operation not permitted 环境变量配置 先启动ebook-convert完成第一次启动配置，然后关闭。接着在命令行窗口修改环境配置文件，加入EBOOK_PATH（ebook-convert命令的所在目录） vim ~/.bash_profile export EBOOK_PATH=/Applications/calibre.app/Contents/MacOS export PATH=$PATH:$EBOOK_PATH 然后刷新一下刚刚的配置: source ~/.bash_profile 最后测试一下ebook-convert指令是否能正常被调用： $ ebook-convert --version ebook-convert (calibre 2.81.0) Created by: Kovid Goyal 大功告成！下面就可以使用gitbook pdf ./ ./mybook.pdf 命令把你的项目生成pdf文档了！ 封面 Gitbook 的封面可以通过插件auto cover自动生成，也可以自己配置。 如果要使用自定义的封面，在书籍的根目录下放置 cover.jpg，如果想要小版本封面可以放置 cover_small.jpg，文件格式必须为 jpg 一个合格的封面应遵守以下准则： 大小要求 cover.jpg 1800x2360 像素 , cover_small.jpg 200x262 不要有边框 清晰可见的书名 任何重要的文本应该在小版本中可见 自动封面 GitBook插件 (autocover) 同样可以用来为你生成一个封面文件，或者仅仅从大封面中生成 cover_small.jpg。这个插件默认会被添加到托管的书本中。 生成PDF 进入文档项目目录，输入gitbook pdf ./ ./gitbook.pdf $ cd ~/gitbook-cn $ gitbook pdf ./ ./gitbook.pdf pdf： 表示生成pdf格式，还有epub、mobi可选 ./ ： 表示需要生成书籍的项目根目录 ./gitbook.pdf : 表示生成书籍的名称 如果你的书籍有多种语言，就会生成多本书籍，书籍的名称会以语言结尾 Gitbook 发布 可以使用Github Pages服务将我们写的Gitbook发布到互联网上，前提是你已经了解了Git、Github及Github Pages的使用。 发布到 Gitbook.com Gitbook.com 是一个发布gitbook编写书籍的在线网站，提供公开和私有的托管服务，和GitHub一样，私有的Gitbook是需要付费使用的。但是公开的书籍是无上限的，使用在线的Gitbook可以让未接触过Git和Markdown的作者轻松的创建书籍，并且在线的编辑器可以让作者安心的只关心内容，而不必在意排版，并且支持多人协作编写。 在Gitbook上建立账户，新建项目之后，其实也是一个 Git 项目，如果对 Git 熟悉，将本地内容推送到远端即可。 发布到Github Pages GitHub Pages 是 GitHub 提供的静态网站托管服务。 GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下： https://.github.io// GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 你可以在项目页面右下角setting中看到： 小浩就是直接将静态资源设置为第二个master 分支的 /docs 目录，然后开发完后因为gitbook serve已经生成打包了_book，所以直接重命名为 docs文件夹，之后直接提交到master分支。 将静态网站直接发布到Github Pages 可以将编写好的.md文件通过Gitbook处理成静态网站，然后发布到Github Pages上。 将md文件与Github Pages静态文件存放在一个仓库中。md文件为master分支，而html文件为 gh-pages分支。 下面将介绍使用一个仓库托管源码，而使用 Travis 自动将静态网站发布到 gh-pages 分支中。这样就可以避免提交源码的同时，还需要同步一遍 gh-pages 分支。 domenic 制作了一个脚本，当 master 分支更新时，自动使用 CI Travis 拉取更新，然后和 gh-pages 分支做比较，如果有差异了，自动将 master 分支的修改提交到 gh-pages 分支。 使用项目的Pages服务 除了上面的直接发布静态文件到Github Pages的方法以外，还可以使用一个单独的项目的Github Pages功能。 创建仓库与分支 登陆到Github，创建一个新的仓库，名称我们就命名为gitbook-tutorial，这样我就得到一个gitbook-tutorial仓库。 克隆仓库到本地： git clone git@github.com:/USER_NAME/gitbook-tutorial.git 创建一个新分支： git checkout -b gh-pages，注意，分支名必须为gh-pages。 将分支push到仓库： git push -u origin gh-pages。 切换到主分支：git checkout master。 经过这一步处理，我们已经创建了gh-pages分支了，有了这个分支，Github会自动为你分配一个网址。 http://USERNAME.github.io/gitbook-tutorial 打包gitbook项目发布到GitHub pages 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。 $ git subtree push --prefix=_book origin gh-pages 或者在生成静态网页时，将保存的目录指定为 ./docs $ $ gitbook build ./ ./docs 然后直接推送到 GitHub 仓库的。 $ git push origin master "},"Tools/markdown/":{"url":"Tools/markdown/","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 Markdown 标题 Markdown 标题有两种格式。 第一种：使用 = 和 - 标记一级和二级标题 这是一个一级标题 ============================ 这是一个二级标题 -------------------------------------------------- 第二种：使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题字号最大，依级递减。 显示效果： 段落格式 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 第一行 ☞末尾添加两个空格 就可换行 第二行 当然也可以在段落后面使用一个空行来表示重新开始一个段落。 第一行 第二段落第一行 字体 Markdown使用星号*和底线_作为标记强调字词的符号，被*或_包围的字词会被转成用标签包围，用两个如**或__包起来的话， 则会被转成，用~~包起来的话，则会被转成，但是目前markdownPad2和GitHub的markdown并不支持删除线这个语法功能， 可以直接用html的或代替，而且下划线只能通过 HTML 的 标签来实现。 *斜体* 或 _斜体_ **粗体** 或 __粗体__ ***加粗斜体*** 或 ___加粗斜体___ ~~删除线~~ 带下划线文本 显示效果： 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 带下划线文本 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ---------- 显示效果都是一样的一条分隔线，显示效果如下 脚注 脚注是对文本的补充说明。在需要添加注脚的文字后加上脚注名字[^注脚名字],称为脚注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 [!danger] 脚注 id 必须唯一；经测试脚注根据不同编译器会有不同效果。区别如下：一般线上的markdown编译器效果为：（1）无论脚注 id 如何起名，显示时一律标为数字，并且按出现顺序排列；（2）即使你没有把注脚写在文末，显示出来的效果也会自动归类到文章的最后。 gitbook Cli 脚注与注脚之间必须空一行，不然会失效。注脚并不会自动归类到文章最后，所以最好手动写到文章最后。 创建脚注格式类似这样 [^HQBOOK]。 [^HQBOOK]: hqbook -- A book for note。 gitbook Cli显示效果：创建脚注格式类似这样 HQBOOK。 其他markdown编译器显示效果： 列表 无序列表 使用 *，+，- 表示无序列表，三个都显示为实心圆点。 - 无序列表项 一 - 无序列表项 二 - 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表 有序列表则使用数字接着一个英文句点.再加个空格。 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 列表嵌套 列表嵌套只需在子列表中的选项添加四个空格即可。 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 列表特殊情况 在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 2008. 北京奥运会欢迎您！ 会显示成： 北京奥运会欢迎您！ 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 2008\\. 北京奥运会欢迎您！ 才能正常显示成：2008. 北京奥运会欢迎您！ 区块引用 Markdown 区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号： > 这是一个有两段文字的引用, > Markdown 区块引用 > hqbook > 学的不仅是技术更是梦想 显示效果： 这是一个有两段文字的引用,Markdown 区块引用 hqbook学的不仅是技术更是梦想 Markdown 也允许你偷懒只在整个段落的第一行最前面加上`>``： > 这是一个有两段文字的引用, Markdown 区块引用 > hqbook 学的不仅是技术更是梦想 显示效果： 这是一个有两段文字的引用,Markdown 区块引用 hqbook学的不仅是技术更是梦想 区块的多层嵌套 区块引用可以嵌套，一个> 符号是最外层，两个> 符号是第一层嵌套，以此类推： > 最外层 >> 第一层嵌套 >>> 第二层嵌套 显示效果： 最外层 第一层嵌套 第二层嵌套 区块中引用其它要素 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： > 区块中使用列表 > 1. 第一项 > 2. 第二项 > + 第一项 > + 第二项 > > 给出一些例子代码： > return shell_exec(\"echo $input | $markdown_script\"); 显示效果： 区块中使用列表 第一项 第二项 第一项 第二项 给出一些例子代码：return shell_exec(\"echo $input | $markdown_script\"); 列表中使用区块 如果要在列表项目内放进区块，那么就需要在 > 前添加四个空格的缩进。 * 第一项 > hqbook > A book for note * 第二项 显示效果： 第一项 hqbookA book for note 第二项 代码 [!Tip] Markdown 支持使用原生html代码 如果是段落上的一个函数或片段的代码可以用反引号`把它包起来，也可以将某些字眼加上反引号达到显眼的作用。例如： `printf()` 函数 随便敲打几个字，在这行字里面用`反引号`突出某些字眼，比如`hqbook` 显示效果： printf() 函数随便敲打几个字，在这行字里面用反引号突出某些字眼，比如hqbook 代码区块 代码区块使用```包裹一段代码，并指定一种语言（也可以不指定）： ```javascript $(document).ready(function () { alert('hqbook'); }); ``` 显示效果： $(document).ready(function () { alert('hqbook'); }); 你也可以用4 个空格或者一个制表符（Tab 键） 显示效果： 支持的 HTML 元素 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有： 等 ，如： 使用 Ctrl+Alt+Del 重启电脑 显示效果： 使用 Ctrl+Alt+Del 重启电脑 转义 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 符号 符号 符号 \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 * 感叹号 超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 行内式 语法说明： []里写链接文字，()里写链接地址, ()里面\" \"中的内容可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 \"链接标题\")这样的形式。链接地址与链接标题前有一个空格。 欢迎来到[Markdown语法篇](https://haoqiangchen.github.io/hqbook/Tools/markdown/) 欢迎来到[Markdown语法篇](https://haoqiangchen.github.io/hqbook/Tools/markdown/ \"Markdown语法篇\") 显示效果： 欢迎来到Markdown语法篇 欢迎来到Markdown语法篇 参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明： 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 \"链接标题\"，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址的形式，见代码的最后一行。 欢迎阅读本[Markdown语法篇][1]，还有这几篇高手总结的也不错：[入门篇][2]、 [简明版][3]、[完整版][4]，我就喜欢把百家汇成[自己一家][]^_^。 [1]:https://haoqiangchen.github.io/hqbook/Tools/markdown/ \"Markdown语法篇\" [2]:https://www.jianshu.com/p/1e402922ee32 \"入门篇\" [3]:https://www.jianshu.com/p/6bf6735993ec \"简明版\" [4]:https://www.runoob.com/markdown/md-tutorial.html \"完整版\" [自己一家]:https://haoqiangchen.github.io/hqbook/Tools/markdown/ 显示效果： 欢迎阅读本Markdown语法篇，还有这几篇高手总结的也不错：入门篇、简明版、完整版，我就喜欢把百家汇成自己一家^_^。 自动链接 语法说明： Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来，Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 显示效果： http://example.com/address@example.com 锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有markdown的脚注。这些根本上都是用锚点来实现的。 语法描述： 使用[TOC]标记编辑器会把所有标题写到目录大纲中，该功能原生不支持； 在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接[标记](#标记)。 直接HTML语法锚点功能。 [TOC] ## 脚注{#footnote} 跳转到[脚注](#footnote) 上面这两种方法原生markdown(GitHub)都不支持，不过第二种方法在`gitbook cli`可行 显示效果： 跳转到脚注 图片 图片的创建方式与超链接相似（在超链接前面加个!感叹号），而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 [!Tip] Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签 行内式 语法说明：![图片Alt](图片地址 \"图片Title\") 美丽花儿： ![美丽花儿](../../images/markdown/flower.jpg \"美丽花儿\") 显示效果： 美丽花儿： 参考式 语法说明： 在文档要插入图片的地方写![图片Alt][标记] 在文档的最后写上[标记]:图片地址 \"Title\" 美丽花儿： ![美丽花儿][flower] [flower]:../../images/markdown/flower.jpg \"美丽花儿\" 显示效果： 美丽花儿： 表格 语法说明： 表格使用|来分隔不同的单元格，第一行为表头，第二行使用-来分隔表头和主体部分，第三行开始每一行为一个表格行； 列于列之间用管道符|隔开。原生markdown的表格每一行的两边也要有管道符，而有些编辑器是可以省略的，具体使用视情况而定； 第二行还可以为不同的列指定对齐方向。默认为左对齐。有时候为了代码可读好看，第二行-可以使用多个。 :-或者- 表格内容和表头居左对齐 :-: 居中对齐 -: 右对齐 | 表头 | 左对齐 | 居中对齐 | 右对齐 | | ---- | :--- | :---: | ---: | | 单元格 | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 单元格 | [!danger] 因为 | 管道符在 markdown 表格中已经表示 分隔不同的单元格，所以如果单元格里面本身需要用到 |, 那么可以使用 Unicode编码 &#124; 显示效果： 表头 左对齐 居中对齐 右对齐 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 LaTeX 公式 [!danger] 原生markdown不支持LaTeX 公式，有两种可以解决，一种在线LaTeX 数学公式编辑工具生成图片展示，一种使用gitbook插件 在线LaTeX 数学公式编辑工具 可以用codecogs的云服务，在线LaTeX 数学公式编辑工具，api+一大串LaTex，比如： 当然这么强大的在线公式编辑器肯定提供了在线GUI给大家，打开网址：http://www.codecogs.com/latex/eqneditor.php， 你就可以随心所欲的编辑公式了，它同样想Mathtype一样提供了不少模板，直接编辑，也很方便。编辑完成之后，页面上就会实时得到编辑的Latex格式公式图片， 右击图片，选择“属性”，复制其链接地址，就是其引用地址了。（这种麻烦操作当然是针对IE了，其他浏览器直接点“复制图片地址”）或者这个网址：http://latex.codecogs.com/这个网址的使用方法：![](http://latex.codecogs.com/gif.latex?\\\\frac{1}{1+sin(x)}\\) + 生成的公式地址 gitbook插件 数学插件 & Tex 有不少gitbook插件 支持 Tex 公式绘制，比如mathjax 和 katex，具体可看数学插件 $ 表示行内公式 支持LaTeX 公式的话： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 不支持则使用 ![](http://latex.codecogs.com/gif.latex?E=mc^2) 来表达。 显示效果： 支持LaTeX 公式的话：质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。不支持则使用 来表达。 $$ 表示整行公式 当你需要在编辑器中插入数学公式时，可以使用两个美元符$$包裹TeX或LaTeX格式的数学公式来实现。提交后，问答和文章页会根据需要加载Mathjax对数学公式进行渲染。如： 支持LaTeX 公式的话： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$ 原生不支持，可使用以下图片： ![](http://latex.codecogs.com/gif.latex?\\\\sum_{i=1}^n&space;a_i=0 \"\\sum_{i=1}^n a_i=0\") ![](http://latex.codecogs.com/gif.latex?\\\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj}&space;z_k} \"\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}\") 显示效果： 访问 MathJax 参考更多使用方法。 流程图 [!danger] 原生markdown不支持流程图，有两种可以解决，一种用一些支持流程图的编辑器先画出来，然后截图生成图片展示，一种使用gitbook插件mermaid 举例： 标准流程图源码格式： ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框(是或否?) sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st->op->cond cond(yes)->io->e cond(no)->sub1(right)->op ``` UML时序图源码样例： ```sequence 对象A->对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B-->对象A: 我很好(响应) 对象A->对象B: 你真的好吗？ ``` 显示效果： 更多语法参考：流程图语法参考 HQBOOK. hqbook -- A book for note。 ↩ "},"Frontend/HTML/":{"url":"Frontend/HTML/","title":"HTML","keywords":"","body":" HTML超文本标记语言 WWW 是“World Wide Web”（全球广域网）的缩写，简称为Web，中文又称为“万维网”。 HTML（Hypertext Markup Language，超文本标记语言）是一种文本类、解释执行的标记语言， 用于编写要通过WWW显示的超文本文件，称为HTML文件，也叫Web页面或网页。扩展名为.html或.htm 。 HTML文件的组成包含两部分内容：一是HTML标记；二是HTML标记所设置的内容。 HTML基础 文档类型：规范的HTML/XHTML文档需要以标记声明开始的。用于指定DTD(说明当前这个html版本) HTML文件的基本结构: 头部(head)，标题(title)，页面主体(body) HTML标记: html文件的开始和结束标签： html中标签的大致写法： 由开始标签和结束标签组成,空标签写法为：,双标签 标签名不区分大小写，但在XHTML中必须小写 标签具有属性，属性用来表示标签的性质和特征，属性在一开始的标签中指定，如下图： 页面的头部标记 HTML头部标记 : 设定显示在浏览器标题栏中的内容 : 定义网页的字符集、关键字、描述信息等内容 : 设置CSS层叠样式表的内容 : 对外部文件的链接 : 设置页面脚本或链接外部脚本文件 元信息标记 定义文件编码 搜索引擎优化-关键字 搜索引擎优化-描述 设置页面刷新或者跳转 网页标题栏图标 页面的主题标记 一个网站的三大元素: 图片，超链接，文字 添加网页背景图片 默认情况下，背景图片会随着页面的滚动而滚动，设置标记的bgproperties=\"fixed\",可以使背景图片固定不动。 3. 设置网页链接文字颜色 link属性设置未访问链接文字颜色；alink属性设置正在访问链接文字颜色；vlink属性设置访问过后的链接文字颜色 4. 设置网页边距 设置网页与浏览器边框的间距 HTML的注意事项和建议 凡是标签都应该闭合！ 凡是标签都应该小写！ 文件编码跟设置的编码保持一致！ 标签属性加引号(英文输入法下的引号) HTML缩进统一使用tab键 文字与段落标记 标题字 h1~h6 h1的字最大，递减至 h6 最小 标题字 2. 空格 在HTML里面，浏览器不能解析源代码中使用的Enter键，所有的空格，换行符，水平制表符等等。无论你打再多个，都会视为一个空格。 3. 字体标签 文字内容 属性 说明 color 颜色,默认黑色 size 默认字号为3号字。取值范围1~7，可+1到+7，-1到-7(正负取值相对于页面默认字号)，超出取值范围，与取值范围的最近的值效果相同。 face 默认宋体[黑体,微软雅黑...] 4. 字体格式化标签 {#tagSymbol} 标签 意义 标签 意义 italic,斜体 斜体 blod,加粗 粗体 大字号 小字号 underline,下划线 删除线 删除线 删除线 引用\"\" 举例 高亮 上标字 下标字 注释 注释 注释 举例： OJ(Orange Juice) OJ(Orange Juice) (x+y)2 = x2 + y2 + 2xy (x+y)2 = x2 + y2 + 2xy 5. 注释语句 语法： 为了提高代码的维护性和可读性，常常在源代码中添加注释语句，用于对代码进行说明。注释语句并不显示在浏览器中。 6. 实体字符实体名称对大小写敏感！ HTML 中有用的字符实体 实体字符 描述 实体名称 实体编号 实体字符 描述 实体名称 实体编号 空格 &emsp; 这个兼容性比较好 空格 &nbsp; 有些浏览器不能使用 &#160; 小于号 &lt; &#60; > 大于号 &gt; &#62; \" 引号 &quot; &#34; ' 撇号 &apos; (IE不支持) &#39; & 和号 &amp; &#38; ¥ 元 yen &yen; &#165; x 乘号 &times; &#215; ÷ 除号 &divide; &#247; © 版权 &copy; &#169; ® 商标 &reg; &#174; html特殊符号对照表 7. 段落标记 段落标签 全称: paragraph 语法说明：在HTML中即可使用单标记也可使用双标记,但XHTML只能用双标记。区别是双标记会与上下文同时产生一空行的间隔,而单标记只与上文产生一空行间隔 换行标签 居中标记 缩排标记 预格式化标记 水平线标签 noshade 实心的不带阴影的效果 超链接a标签 属性 属性 描述 href 规定链接指向的页面的 URL。 title 指定元素的提示文本。 name 规定锚的名称。 download 规定被下载的超链接目标。 target 规定在何处打开链接文档。 标签的 target 属性 属性值 描述 _seft 默认。在相同的框架中打开被链接文档。 _blank 在新窗口中打开被链接文档。 _parent 在上一级窗口中打开，一般在框架页面中经常使用。 _top 在浏览器的整个窗口中打开，忽略任何框架。 framename 在指定的框架窗口中打开链接文档。 链接类型 引用外部链接: 超级链接 引用内部链接: 内部链接是指在同一个网站内部，不同网页之间的链接关系 锚点，也叫书签链接。锚点需要满足两个条件。锚点名，锚链接 点击跳转到顶部 ...--> 4. 图片链接 5. foxmail发邮箱的软件,发送邮箱,比较少用 联系我们 6. skype手机调试，在移动端很有用。 拨打 发短信 7. 脚本链接 欢迎访问 8. 下载链接：当连接的href加载的是浏览器无法打开的文件，比如zip,rar。是会提供下载的下载 链接路径 在当前目录下，直接写文件名 (默认 ./ 当前目录)本地文件 当文件在当前目录的某个(dir)文件夹下，这么来写本地文件 当文件在当前目录的上一级，这么来写 (使用 ../ 返回上一层)本地文件 绝对路径用绝对路径打开图片 图片标签 属性 属性 描述 src 图片的来源，路径。(source) alt 图片加载失败的说明文字。建议写图片标签的时候都加上，有利于SEO优化。 width 宽度(如果只设置一个宽度或高度，那么对应得高度或宽度会等比例放大缩小) height 高度(如果只设置一个宽度或高度，那么对应得高度或宽度会等比例放大缩小) hspace 设置图片与周围对象的水平间距 vspace 设置图片与周围对象的垂直间距 title 提示信息。 border 图片的边框。(后面课程中会经常用到) align 设置图片与周围对象的对齐方式(可取值有:top、bottom、middle、left、right) 图像热区 概念：图片映射是指源端点为图片热区的超链接。一幅图像被切分成不同的区域，每一个区域可以链接到不同的地址，这些区域称为图像的热区。 基本语法： area标签属性 描述 类型shape属性值 描述 shape 类型 rect 矩形（2个坐标） coords 坐标 circle 圆形（1个） href 跳转地址 poly 多边形（N个） 链接属性href(a标签和area标签中可使用该属性)：当链接到不可解析的文件时会提示下载信息 什么地方用图像热区呢？一般如果图片很大，很长，只取某部分，那就使用图像热区。 图像热区超级不好调试的，会以目标图片的左上角为原点，就是占位大小不包括margin，占位大小有占位宽和站位高。占位宽=width+border+padding;站位高=height+border+padding;而这个可以使用photoshop找到坐标，使用到标尺等工具。使用photoshop打开图片->将鼠标放在坐标上->在控制面板查看坐标信息 列表 有序列表 这里是第1个li 这里是第2个li 这里是第3个li ol属性： type : 数字(1); 大小写字母(A,a); 大小写罗马数字(I,i) start: \"起始编号位序\"表示列表项的开始编号所处的位置序号，即li前面开始的数值 --> 无序列表 这里是第1个li 这里是第2个li 这里是第3个li ul属性： type : 实心圆(disc); 空心圆(circle); 实心矩形(square) 该属性顺序是li中继续包含ul后的type默认属性,后面默认为实心矩形 [!danger] 无论是有序列表还是无序列表，ul和ol能接的标签只能是li，但li中可以添加任意标签 定义列表 html是什么 HyperText Markup Languagehtml 是一种超文本标记语言 dd标签相当于其他列表中的li标签，可以在其中添加任意标签，不过建议只放dt和dd标签，一般情况下使用标签+样式实现文本的解析，不使用多个dd或dt标签 定义列表的应用场景 做网站尾部的相关信息 做图文混排 嵌套列表 -->无序列表 -->有序列表 ... -->无序列表中嵌套了一个有序列表 表格 表格标签 标签 描述 标签 描述 标签 描述 定义表格 定义表格的表头 定义表格标题 定义表格列的组 定义用于表格列的属性 定义表格的页眉 定义表格的主体 定义表格的页脚 定义表格的行 定义表格单元 表格属性 属性 描述 属性 描述 属性 描述 width 宽 height 高 summary 摘要 title 提示信息 bgcolor 背景颜色 background 背景图片 align 水平方向对齐 valign 垂直方向对齐 cellspacing 单元格之间的空白(默认2px) cellpadding 内容与单元格的空白 colspan 表示横向合并单元格 rowspan 表示纵向合并单元格 border 规定表格边框的宽度。 frame 规定外侧边框的哪个部分是可见的。 rules 规定内侧边框的哪个部分是可见的。 对齐属性 align: 水平方向对齐,值为left,center,right. 适用于table,tr,td valign: 垂直方向对齐。值为top,middle,bottom. 适用于tr,td cellspacing : 单元格之间的空白(默认2px) 适用于table cellpadding : 内容与单元格的空白 适用于table bgcolor、background 两个属性也适用与表格。(table,tr,td)在表格里面给宽度并不能真正的限制死表格的宽度，如果内容超出表格的实质宽高，依然会将表格的单元格甚至整个表格撑开 summary 属性规定表格内容的摘要。summary 属性不会对普通浏览器中产生任何视觉变化。屏幕阅读器可以利用该属性。 frame和rules属性，可以控制边框的显示。frame属性控制着表格最外围的四条边框的可见性，而rules则控制着表格内部边框的可见性。 frame属性可取的值及含义如下： 属性值 描述 属性值 描述 above 显示上部的外侧边框 below 显示下部的外侧边框 lhs 显示左边的外侧边框 rhs 显示右边的外侧边框 hsides 显示上部和下部的外侧边框 vsides 显示左边和右边的外侧边框 void 默认值，表示不显示表格最外围的边框 box 在所有四个边上显示外侧边框 border 在所有四个边上显示外侧边框 rules 属性可取的值有五个，分别是： none - 默认值，无边框 rows - 为行加边框 cols - 为列加边框 groups - 为行组或列组加边框 all - 为所有行列（单元格）加边框 table的三个基本组成部分：行，列，单元格 表格标题标记： 表格可以分成表头、主体和表尾三部分，在HTML语言中分别用、、表示 [!danger|label: 这里有三个注意点] 和在一张表中都只能有一个，而可以有多个。 必须出现在前面，这样浏览器在接收主体数据之前，就能渲染表尾，有利于加快表格的显示速度。这一点对大型表格尤其重要。 、和里面都必须使用标签。 3. CSS中的table-layout语句：table { table-layout: fixed/auto/inherit } auto表示单元格的大小由内容决定。 fixed表示单元格的大小是固定的，由第一个指定大小的单元格决定；如果所有单元格都没有指定大小，则由第一个单元格的默认大小决定；如果单元格中的内容超出单元格的大小，则用CSS中的overflow命令控制。微软公司声称使用这个命令，表格的显示速度可以加快100倍。 inherit表示从父元素继承table-layout属性的值，任何版本的IE都不支持。 4. 可以用来对行进行分组，而则用来对列进行分组。 比如，下面的代码表示前40列为一组，每列的宽度为20像素。span属性，可以指定colgroup标签能够影响到的列数。在colgroup标签内部，可以使用col标签为这一列组中的每一列指定属性。比如，下面的代码表示列组中每一列的段度为为不同宽度：代码示例： My Ultimate Table cell 1-1cell 1-2cell 1-3cell 1-4 cell 4-1cell 4-2cell 4-3cell 4-4 cell 2-1cell 2-2cell 2-3cell 2-4 cell 3-1cell 3-2cell 3-3cell 3-4 显示效果如下： @[colgroup对列分组]{../../demo/demo.html?demoname=colgroup} ../../images/home/html.png 5. 合并单元格colspan和rowspan 代码示例： 　a test table with merged cells 　average 　redeyes 　heightweight 　males1.90.00340% 　females1.70.00243% 显示效果如下： @[合并单元格]{../../demo/demo.html?demoname=table-merge-cells} ../../images/html/table.gif \"rect\" 表单 form表单标记 …… 表单属性 action 用于指定表单的服务端程序,规定当提交表单时，向何处发送表单数据。action取值为:第一，一个URL（绝对URL/相对URL），一般指向服务器端一个程序，程序接受到表单提交过来的数据（即表单元素值）作相应处理。比如： 当用户提交这个表单时，第一，服务器将执行网址http://i.blog.sina.com.cn//上的名为reg.ashx的一般处理程序。第二，使用mailto协议的URL地址，这样会将表单内容以电子邮件的形式发送出去。这种情况比较少见的，因为它要求访问者的计算机上安装和正确设置好了邮件发送程序。第三，空值，如果action为空或不写，表示提交给当前页面。 method 该属性定义浏览器将表单中的数据提交给服务器处理程序的方式。最常用的是get和post，默认时使用get方法。 get 与 post 有什么区别呢？ 数据的查询：比如浏览论坛时，URL一般包含了分类、页码数、每页记录数等信息。 get方式，能一目了然的看到所要查询的信息(条件)。 post 因为隐藏掉了这些信息，不方便进行检验查询条件。 敏感数据的提交(安全性)：对一项记录，进行更改、添加操作时，比如注册用户、更改用户资料等。get 方式附加在URL上，会泄露掉敏感的消息。 post 方式，能隐藏掉敏感的信息。下面各用个例子说明一下： 用get方式点击提交后：URL变为：http://localhost:4778/ashx/login.ashx?login_username=admin&login_pswd=123456 用post方式点击提交后：URL变为：http://localhost:4778/ashx/login.ashx 可以看到只是action指定的URL，参数并没有附加在URL后面。 大数据文本传递：get虽然方便查询，但由于是附加在URL上，各浏览器对URL也有个长度限制。IE:2048字符。Chrome、FF好像是 8182字符。post好像没此限制。 onsubmit 用于指定处理表单的脚本函数 enctype 设置MIME类型，默认值为application/x-www-form-urlencoded。需要上传文件到服务器时，应将该属性设置为multipart/form-data input输入标记 多数表单元素都可使用input定义,为了标识每一个数据，我们需要给表单元素添加name属性，所以name为必设属性，name=\"域名称\" 文本框的主要属性: width 宽度 height 高度 name 名称，在脚本中可作为标识获取数据 maxlength 设置在文本框中最多可输入的字符数 max 规定输入字段的最大值。min 规定输入字段的最小值。max和min属性配合使用，来创建合法值的范围。 size 文本框长度，大约以字节为单位 value 指定文本框的默认值，是在浏览器第一次显示表单或者用户单击重置按钮之后在文本框中显示的值 placeholder 规定帮助用户填写输入字段的提示 autofocus 规定输入字段在页面加载时是否获得焦点 readonly 只读属性，当设置readonly属性后，文本框可以获得焦点，但用户不能改变文本框中的value disabled 禁用，当文本框被禁用时，不能获得焦点，当然，用户也不能改变文本框的值。并且在提交表单时，浏览器不会将该文本框的值发送给服务器 required 指示输入字段的值是必需的 pattern 规定输入字段的值的模式或格式，例如 pattern=\"[0-9]\" 表示输入值必须是 0 与 9 之间的数字 type 规定input元素的类型，下面详细介绍 type属性规定input元素的类型 文本框text: 输入信息以明文显示 用户名: 密码框password: 以\"*\"或\"●\"符号回显所输入的字符，从而起到保密的作用 密码: 隐藏域hidden: 隐藏域不会被浏览者看到，它主要用于在不同页面传递域中所设定的值 文件域file: 文件域可以将本地文件上传到服务器端,文件上传没有默认值,利用这项功能时，在 form 标签中要指定method属性。要把method 指定为post, enctype属性指定为 multipart/form-data。否则无法上传文件内容 单选按钮radio: 在一组选项中进行单项选择，以一个圆框表示 使用方式：要实现单选功能，name值必须相等。使用name相同的一组单选按钮，不同radio设定不同的value值，这样通过取指定name的值就可以知道谁被选中了，不用单独的判断。单选按钮的元素值由value属性显式设置，表单提交时，选中项的value和name被打包发送，不显式设置value。 性别: 男: 女: 复选按钮checkbox: 在一组选项中进行多项选择，以一个方框表示 爱好: 音乐 旅游 阅读 提交按钮submit: 用于将表单内容提交到指定服务器处理程序或指定客户端脚本进行处理 普通按钮button: 用于激发提交表单动作，配合JavaScript脚本对表单执行处理操作 重置按钮reset: 用于清楚表单中所输入的内容，将表单内容恢复成默认的状态 图像按钮image: 按钮外形以图像表示，功能与提交按钮一样，具有提交表单内容的作用 select选择列表标记 选择列表 一次可以选择多个列表选项，且一次可以显示1个以上列表选项的选择列表select 标记用于声明选择列表，option标记用于设置各个选项 香蕉 苹果 西瓜 葡萄 下拉列表 一次只能选择一个列表选项，且一次只能显示一个列表选项的选择列表，即size默认1不能设置 size和 multiple属性 标签用于组合选项，即给选项分组类别,属性为label,指定选项组合名称 --> 华盛顿 旧金山 广州 湛江 textarea文本域标记 一般用于给用户填写备注信息或留言信息的多行多列文本区域 ...(此处输入的为默认文本，比如)请在此处输入备注信息 label标签：为input元素定义标注 lable元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在label元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 [!danger] \"for\"属性可把label绑定到另外一个元素。请把\"for\"属性的值设置为相关元素的id属性的值。即为下面说的隐式的联系。 隐式和显式的联系 标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容，这样的就是隐式形式， 或者为标签下的for属性命名一个目标表单id，这样就是显式形式。 显式的联系 Social Security Number: 隐式的联系 Date of Birth: fieldset标签 把表单中元素组合起来，通俗的讲就是把表单围起来，顺便给个标题注释，看起来更规整。 基本语法： ... ... demo 我最喜爱的: 计算机 旅游 购物 显示效果 我最喜爱的: 计算机 旅游 购物 框架 框架概述 框架的作用，就是把浏览器窗口划分成若干个小窗口，每个小窗口可以分别显示不同的网页。这样在一个页面中可以同时显示不同网页内容，不同窗口的内容相互独立。框架的主要用途是导航，通常会在一个窗口中显示导航条，另外一个窗口则作为内容窗口，用于显示导航栏目的目标页面内容，窗口的内容会根据导航栏目的不同而动态变化。 html框架集与body同级,因此不能同时出现。框架的基本结构主要分为框架集和框架两个部分。 基本语法如下： ... 框架集标记frameset 定义浏览器窗口的分割方式、各分割窗口（框架）的大小以及设置框架边框的颜色和粗细等属性。主要属性有： 属性 说明 属性 说明 属性 说明 border 边框宽度，框架粗细 frameborder 是否显示边框（取值1, 0或yes，no） rows 上下分割窗口 bordercolor 边框颜色 framespacing 边框间距 cols 左右分割窗口 标记对浏览器窗口的分割存在不同的方式，主要分为以下几种类型： cols左右（水平）分割 rows上下（垂直）分割 cols把框架分成左右两半,上下分割使用rows(分成上下两半)。每个框架的大小使用逗号隔开，最后一个使用*会把剩下的都分配给它 嵌套分割：左右上下分割都有。里面再嵌套一个标记. 效果图如下： 框架标记frame 分割得到的每个子窗口都需要显示不同的页面内容，这些页面内容由标记来设置。是个单标记，它必须放在框架集frameset中，分割了几个子窗口就必须对应几个标记。 基本语法： 标记的常用属性有： 属性 属性值 说明 属性 属性值 说明 scrolling yes、no、auto 是否显示滚动条 noresize 禁止改变框架的尺寸大小 border 边框宽度，框架粗细 bordercolor 边框颜色 marginwidth 设置内容与框架窗口左右边框的距离 marginheight 设置内容与框架窗口上下边框的距离 src 显示页面的URL地址 浮动框架标记iframe（也有叫“内嵌框架”的） 浮动框架时一种特殊的框架页面，主要体现在这个框架时嵌套在一个HTML页面中，作为页面的一个组成部分。具有和一样的属性，也有自己的属性： 不支持框架标记noframes 当用户浏览器版本太低不支持框架时，浏览器制作人员无法改变这一现象，所能做的只是告诉用户事实，把显示给用户看的文本信息放在标记对之间；而放在标记后面。如： 抱歉，您的浏览器版本太低，不支持框架，无法看到页面内容，请使用较新的浏览器来浏览。 当用户浏览器版本太低不支持框架时，浏览器窗口将显示标记对之间的文本内容，否则将显示中各个框架的页面内容。 框架与超链接 一般情况下在框架中的a链接使用target属性实现框架内文件跳转时： href 一直不变，即指向打开的文件路径不需要变 _self 自己框架页面打开 _blank 新页面打开 _top 顶级框架页面打开 _parent 到其父级框架页面打开 _framename 将我们想要打开的页面在指定的框架中打开 下面用个例子来说明 首先，新建一个网页“框架集和框架.html”，为右侧框架窗口添加\"name\"标识，输入下面的内容： 框架集frameset和框架frame 然后，新建一个网页“menu.html”，在左侧窗口中，设置\"target\"属性显示的窗口名，输入下面的内容： Document qq 百度 淘宝 如下图，刚开始打开这个“框架集和框架.html”这个网页时，显示的效果如下：左边相当于是一个菜单，右边是显示效果，当你单击“百度”或者“淘宝”时都可以链接到相应网站。 HTML颜色 HTML 颜色采用的是 RGB 颜色，是通过对红 (R)、绿 (G)、蓝 (B) 三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色。 1600 万种不同颜色三种颜色 红，绿，蓝的组合从 0 到 255，一共有 1600 万种不同颜色 (256 x 256 x 256)。您可以在编程测试中练习使用 RGB 红色表达方式！在下面的颜色表中你会看到不同的结果，从 0 到 255 的红色，同时设置绿色和蓝色的值为 0 ，随着红色的值变化，不同的值都显示了不同的颜色。 Web 安全色? 数年以前，当大多数计算机仅支持 256 种颜色的时候，一系列 216 种 Web 安全色作为 Web 标准被建议使用。其中的原因是，微软和 Mac 操作系统使用了 40 种不同的保留的固定系统颜色（双方大约各使用 20 种）。我们不确定如今这么做的意义有多大，因为越来越多的计算机有能力处理数百万种颜色，不过做选择还是你自己。最初，216 跨平台 Web 安全色被用来确保：当计算机使用 256 色调色板时，所有的计算机能够正确地显示所有的颜色。 000000 000033 000066 000099 0000CC 0000FF 003300 003333 003366 003399 0033CC 0033FF 006600 006633 006666 006699 0066CC 0066FF 009900 009933 009966 009999 0099CC 0099FF 00CC00 00CC33 00CC66 00CC99 00CCCC 00CCFF 00FF00 00FF33 00FF66 00FF99 00FFCC 00FFFF 330000 330033 330066 330099 3300CC 3300FF 333300 333333 333366 333399 3333CC 3333FF 336600 336633 336666 336699 3366CC 3366FF 339900 339933 339966 339999 3399CC 3399FF 33CC00 33CC33 33CC66 33CC99 33CCCC 33CCFF 33FF00 33FF33 33FF66 33FF99 33FFCC 33FFFF 660000 660033 660066 660099 6600CC 6600FF 663300 663333 663366 663399 6633CC 6633FF 666600 666633 666666 666699 6666CC 6666FF 669900 669933 669966 669999 6699CC 6699FF 66CC00 66CC33 66CC66 66CC99 66CCCC 66CCFF 66FF00 66FF33 66FF66 66FF99 66FFCC 66FFFF 990000 990033 990066 990099 9900CC 9900FF 993300 993333 993366 993399 9933CC 9933FF 996600 996633 996666 996699 9966CC 9966FF 999900 999933 999966 999999 9999CC 9999FF 99CC00 99CC33 99CC66 99CC99 99CCCC 99CCFF 99FF00 99FF33 99FF66 99FF99 99FFCC 99FFFF CC0000 CC0033 CC0066 CC0099 CC00CC CC00FF CC3300 CC3333 CC3366 CC3399 CC33CC CC33FF CC6600 CC6633 CC6666 CC6699 CC66CC CC66FF CC9900 CC9933 CC9966 CC9999 CC99CC CC99FF CCCC00 CCCC33 CCCC66 CCCC99 CCCCCC CCCCFF CCFF00 CCFF33 CCFF66 CCFF99 CCFFCC CCFFFF FF0000 FF0033 FF0066 FF0099 FF00CC FF00FF FF3300 FF3333 FF3366 FF3399 FF33CC FF33FF FF6600 FF6633 FF6666 FF6699 FF66CC FF66FF FF9900 FF9933 FF9966 FF9999 FF99CC FF99FF FFCC00 FFCC33 FFCC66 FFCC99 FFCCCC FFCCFF FFFF00 FFFF33 FFFF66 FFFF99 FFFFCC FFFFFF HTML 常用颜色代码表  #000000 #2F0000 #600030 #460046 #28004D #272727 #4D0000 #820041 #5E005E #3A006F #3C3C3C #600000 #9F0050 #750075 #4B0091 #4F4F4F #750000 #BF0060 #930093 #5B00AE #5B5B5B #930000 #D9006C #AE00AE #6F00D2 #6C6C6C #AE0000 #F00078 #D200D2 #8600FF #7B7B7B #CE0000 #FF0080 #E800E8 #921AFF #8E8E8E #EA0000 #FF359A #FF00FF #9F35FF #9D9D9D #FF0000 #FF60AF #FF44FF #B15BFF #ADADAD #FF2D2D #FF79BC #FF77FF #BE77FF #BEBEBE #FF5151 #FF95CA #FF8EFF #CA8EFF #d0d0d0 #ff7575 #ffaad5 #ffa6ff #d3a4ff #E0E0E0 #FF9797 #FFC1E0 #FFBFFF #DCB5FF #F0F0F0 #FFB5B5 #FFD9EC #FFD0FF #E6CAFF #FCFCFC #FFD2D2 #FFECF5 #FFE6FF #F1E1FF #FFFFFF #FFECEC #FFF7FB #FFF7FF #FAF4FF #000079 #000079 #003E3E #006030 #006000 #000093 #003D79 #005757 #01814A #007500 #0000C6 #004B97 #007979 #019858 #009100 #0000C6 #005AB5 #009393 #01B468 #00A600 #0000E3 #0066CC #00AEAE #02C874 #00BB00 #2828FF #0072E3 #00CACA #02DF82 #00DB00 #4A4AFF #0080FF #00E3E3 #02F78E #00EC00 #6A6AFF #2894FF #00FFFF #1AFD9C #28FF28 #7D7DFF #46A3FF #4DFFFF #4EFEB3 #53FF53 #9393FF #66B3FF #80FFFF #7AFEC6 #79FF79 #AAAAFF #84C1FF #A6FFFF #96FED1 #93FF93 #B9B9FF #97CBFF #BBFFFF #ADFEDC #A6FFA6 #CECEFF #ACD6FF #CAFFFF #C1FFE4 #BBFFBB #DDDDFF #C4E1FF #D9FFFF #D7FFEE #CEFFCE #ECECFF #D2E9FF #ECFFFF #E8FFF5 #DFFFDF #FBFBFF #ECF5FF #FDFFFF #FBFFFD #F0FFF0 #467500 #424200 #5B4B00 #844200 #642100 #548C00 #5B5B00 #796400 #9F5000 #842B00 #64A600 #737300 #977C00 #BB5E00 #A23400 #73BF00 #8C8C00 #AE8F00 #D26900 #BB3D00 #82D900 #A6A600 #C6A300 #EA7500 #D94600 #8CEA00 #C4C400 #D9B300 #FF8000 #F75000 #9AFF02 #E1E100 #EAC100 #FF9224 #FF5809 #A8FF24 #F9F900 #FFD306 #FFA042 #FF8040 #B7FF4A #FFFF37 #FFDC35 #FFAF60 #FF8F59 #C2FF68 #FFFF6F #FFE153 #FFBB77 #FF9D6F #CCFF80 #FFFF93 #FFE66F #FFC78E #FFAD86 #D3FF93 #FFFFAA #FFED97 #FFD1A4 #FFBD9D #DEFFAC #FFFFB9 #FFF0AC #FFDCB9 #FFCBB3 #E8FFC4 #FFFFCE #FFF4C1 #FFE4CA #FFDAC8 #EFFFD7 #FFFFDF #FFF8D7 #FFEEDD #FFE6D9 #F5FFE8 #FFFFF4 #FFFCEC #FFFAF4 #FFF3EE #613030 #616130 #336666 #484891 #6C3365 #743A3A #707038 #3D7878 #5151A2 #7E3D76 #804040 #808040 #408080 #5A5AAD #8F4586 #984B4B #949449 #4F9D9D #7373B9 #9F4D95 #AD5A5A #A5A552 #5CADAD #8080C0 #AE57A4 #B87070 #AFAF61 #6FB7B7 #9999CC #B766AD #C48888 #B9B973 #81C0C0 #A6A6D2 #C07AB8 #CF9E9E #C2C287 #95CACA #B8B8DC #CA8EC2 #D9B3B3 #CDCD9A #A3D1D1 #C7C7E2 #D2A2CC #E1C4C4 #D6D6AD #B3D9D9 #D8D8EB #DAB1D5 #EBD6D6 #DEDEBE #C4E1E1 #E6E6F2 #E2C2DE #F2E6E6 #E8E8D0 #D1E9E9 #F3F3FA #EBD3E8 在网页中嵌入多媒体内容 现在在制作网页时，除了可以在网页中放置文本、图片外，还可以在页面中嵌入声音、视频、动画等多媒体内容，使得页面看上去更加丰富多彩、动感十足。 设置滚动字幕marquee 属性 属性值 说明 —————————————————————————————————————————————————————————————————————————————————————————————————————————————————— demo：`文字从下往上循环滚动` up(从下往上)down(从上往下) direction left(从右往左，默认滚动方向) 设置滚动字幕的滚动方向 (滚动方向) right(从左往右) —————————————————————————————————————————————————————————————————————————————————————————————————————————————————— demo：`设置文字循环交替往返进行滚动` behavior scroll 设置文字循环往复滚动(默认行为) (滚动行为) slide 设置文字只进行一次滚动 alternate 设置文字循环交替往返进行滚动 —————————————————————————————————————————————————————————————————————————————————————————————————————————————————— demo：`滚动文字` scorllamount 设置文字滚动速度，取值为某个数字，越大滚动越快，默认的速度值是6 scrolldelay 设置文字在每一次滚动后，延迟一段时间后再进行下一次滚动，value以毫秒为单位，值越小越快，默认值是100ms —————————————————————————————————————————————————————————————————————————————————————————————————————————————————— 设置字幕的滚动区域、背景颜色、与周围对象的间距等 width 设置文字滚动区域的宽度，可以是数字像素或百分比数值% height 设置文字滚动区域的宽度，可以是数字像素或百分比数值% bgcolor 设置文字滚动区域的背景颜色 hspace 水平间距 vspace 垂直间距 ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————— 设置背景音乐bgsound 嵌入音视频文件embed 属性 说明 src 文件路径 width 以像素为单位定义嵌入式对象的宽度 height 以像素为单位定义嵌入式对象的宽度 loop 设置嵌入式对象的播放是否循环不断，取值true时循环不断，否则只播放一次，默认值是false hidden 设置多媒体播放软件的可视性，默认值是false 嵌入Flash动画object 其中 OBJECT 的classid和codebase的值是必须这么写的，告诉浏览器自动下载flash player的地址,OBJECT标签是用于windows平台的IE浏览器的，EMBED是用于windows和Macintosh平台下的Netscape Navigator浏览器以及Macintosh平台下的IE浏览器，就是所谓的非IE浏览器。windows平台的IE利用Activex控件来播放flash而其它的浏览器则使用Netscape插件技术来播放flash。 代码效果显示如下： @[object标签：嵌入Flash动画]{../../demo/demo.html?demoname=object-flash} ../../images/home/html.png 嵌入Java Applet（扩展） Applet 是用 Java开发的一种小程序，不能独立运行，必须嵌入HTML文件中，并通过支持Java的浏览器来运行。基本语法： 语法说明： XXX.class表示所嵌入的applet类文件，width、height属性用来设置applet文件显示区域，单位是像素。 "},"Frontend/HTML/HTML5.html":{"url":"Frontend/HTML/HTML5.html","title":"HTML5","keywords":"","body":"HTML5 HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。 HTML5的设计目的是为了在移动设备上支持多媒体。 HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。 HTML5简化了许多,它的设计遵循了3个原则:1.兼容性、2.实用性、3.通用访问性 HTML5 浏览器支持 你可以让一些较早的浏览器（不支持HTML5）支持 HTML5。 完美的 IE浏览器 兼容 解决方案 html5shiv.js 引用代码必须放在 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。 HTML5新元素(语义化标签) header元素 标签定义文档或者文档的一部分区域的页眉，又可用于设置文章标题。 元素应该作为介绍内容或者导航链接栏的容器。在一个文档中，您可以定义多个元素。注释： 标签不能被放在 、 或者另一个 元素内部。语法说明: 标记对之间可以包含 h1~h6 六个标题元素，以及p、span等元素。 hgroup元素 标签定义文档的主标题及副标题，也就是标题组合，标记对之间通常只使用 h1~h6 六个标题元素。 hqbook 学的不仅是技术更是梦想 footer元素 footer 元素主要用于为页面或某篇文章定义脚注内容，包括文章的版权信息、作者联系方式等内容，一个页面可以包含多个 footer 元素。 Copyright © 2000-2013 华软 All Rights Reserved 学院地址：广州.从化.广从大道13号 电话：020-87818918 article元素 标签定义独立的内容，页面中一块与上下文不相关的独立内容。比如一个帖子、一篇博客文章等。 标签定义的内容本身必须是有意义的且必须是独立于文档的其余部分。 的潜在来源：论坛帖子、博客文章、新闻故事、评论等。 语法说明: 标记对之间可以包含header、footer、section以及嵌套的article等元素。 section 元素 元素用于对页面的某块内容进行分块，如将该块内容进一步分成章节的标题、内容和页脚等几部分。 语法说明： 标记对之间可以包含 h1~h6 六个标题元素、p元素以及多个article元素以表示该\"分块\"内部又包含多篇文章。此外，还可以嵌套section元素。 nav元素 nav 元素用于定义页面上的各种导航条，一个页面中可以拥有多个 nav 元素，作为整个页面或不同部分内容的导航。nav 唯一不可能出现的位置是 address 元素内基本语法: ### aside 元素 aside 元素表示article元素的内容之外的、与article元素的内容相关的辅助信息，它可以包含与当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。 audio音频标签 标签定义声音，比如音乐或其他音频流。目前，元素支持的3种文件格式：MP3、Wav、Ogg。 属性 说明 src 要播放的音频的URL autoplay 音频在就绪后马上播放 controls 向用户显示音频控件，比如播放/暂停按钮 loop 每当音频结束时重新开始播放 preload 音频在页面加载时进行加载，并预备播放 显示效果如下 video视频标签 标签定义视频，比如电影片段或其他视频流。目前，元素支持三种视频格式：MP4、WebM、Ogg。 属性 说明 src 要播放的视频的URL width 设置视频播放器的宽度 height 设置视频播放器的高度 autoplay 视频在就绪后马上播放 controls 向用户显示视频控件，比如播放/暂停按钮 loop 当媒介文件完成播放后再次开始播放 muted 规定视频的音频输出应该被静音 poster 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像 preload 视频在页面加载时进行加载并预备播放，属性值(none:只有单击了Play按钮才加载视频;metadata:仅加载元数据,例如视频长度、作者、版权) 显示效果如下 图形中的figure及figcaption 元素figure及figcaption实际上不能算作结构性元素，但在组织独立图片、图像、图表及编码列表时仍然很受欢迎。用于对元素进行组合。一般用于图片或视频。 figure的子元素，用于对figure的内容进行说明。每一个figure元素中只能包括一个figcaption元素。图片排列一起可用。常常用到一种图片列表，图片+标题或者图片+标题+简单描述。 黄浦江上的的卢浦大桥 显示效果如下 黄浦江上的的卢浦大桥 time用于表示时间或日期 2016-08-03 datalist选项列表 与input元素配合使用，来定义 input 可能的值。 html css javascript 显示效果如下： progress元素 定义进度条 76% 显示效果如下： 76% details和summary描述文档 details元素用于描述文档或文档某个部分的细节 该元素用于摘录引用等，应该与页面的主要内容区分开的其他内容 Open 属性 展开 summary元素 details元素的标题 hqbook 学的不仅是技术更是梦想 显示效果如下： hqbook 学的不仅是技术更是梦想 其他语义化标签 定义一段对话 老师 2+2等于？ 学生 4 老师 答对了！ 定义文章或页面作者的详细联系信息 需要标记的词或句子 给表单添加一个公钥 智能表单 表单新增属性 autofocus 属性 设置 autofocus 属性，使文本框自动获得焦点 [!danger] 一个页面中最多只能有一个表单元素设置该属性，否则功能将失效，建议对第一个input元素设置autofocus属性。 formaction 属性 所有提交按钮(、、)都可以使用 formaction 属性。HTML5只需添加formaction属性就可实现增加、修改和删除3个按钮功能，不再需要脚本的控制。 autocomplete 属性 若一个元素内包含有 autocomplete=\"off\" 属性，这意味着涉及机密信息，不应被浏览器保存。若表单未定义 autocomplete，则默认设置为开启自动完成、显示输入提示(记忆用户在曾访问网站上所输入的内容)。 pattern 属性 pattern 属性是input元素的验证属性，该属性的值是一个正则表达式，通过这个表达式可以验证输入内容的有效性。 用户名： 密码： placeholder 属性，也叫占位符 占位符值可以给予用户一个快速提示，让他们了解该在输入字段中输入什么，它并不会取代标签元素。当需要用户输入某一特定格式的内容时，占位符显得尤其有用。浏览器会在输入字段显示提示文字。当该输入字段被聚焦(focus)激活，该提示文字则消失，失去焦点时又将自动显示。 姓名： required 属性 定义必填项 required 是一个布尔型属性，包含此属性的表单元素必须被填写。在发送时若仍为空，浏览器就会给予相关相应。 新增的input元素类型 输入类型tel及search tel(电话输入文本) 及 search(搜索关键字输入的文本框) 类型与普通的文本没什么不同，唯一不同的是输入关键字后search文本框右侧会出现一个X按钮，单击X后清空输入内容，由此带来方便。 手机tel：pattern=\"\\d{11}\" title=\"请输入11位的手机号码\" 搜索search： 手机tel：pattern=\"\\d{11}\" title=\"请输入11位的手机号码\" 搜索search： 输入类型url及email URL地址输入框要求必须输入一个包含访问协议的完整的URL路径。 URL网址： email邮箱输入框要求输入正确格式，此外，还可以添加 multiple 属性以允许同时输入多个以逗号分隔的email。 Email： 输入类型number及range number 及 range 类型与包含数值的输入有关，并且支持浮点数表达式。不同的是range类型是用一个滑块来进行输入。输入数值的取值范围由 min和 max两个属性来设置，默认是不限定；调节步长使用 step属性，默认步长是1.基本语法： 滚动条range： 显示效果 滚动条range： 输入类型 color color 类型让 input元素生成一个颜色选择器。 显示效果： datalist 选项列表 datalist 元素用于生成一个隐藏的下拉菜单，其相当于一个“看不见”的 select元素。为什么需要设置id值呢？因为 datalist元素一般需要跟某个文本框结合使用，结合方式是通过将文本框的\"list\"属性值设置为 datalist的 id值，这样就将 datalist绑定到了某个文本框。用户选中选项后datalist元素自动隐藏。记住，跟文本框一起使用并给文本框list和自身id相同的值。 用 datetime(日期和时间),date(日期),time(时间),month,week以及datetime-local(本地日期时间)这几个type类型表示日期和时间 基本语法： datetime包括日期以及时间信息；时间设置始终为UTC。规范允许用户通过浏览器选择不同时区，但input元素的值始终会被转换为UTC格式。datetime属性 字符串必须以 Z 结束以表明它是UTC格式。\"YYYY-MM-DDThh:mm:ss.ssZ\"这是UTC格式.目前，很多浏览器都不支持datetime这个类型。在 date和 month中，时间及时区则被忽略。根据规范定义，date必须是所选月份中的一个有效日期，同时考虑到闰年。年、月、日必须用“ - ”号隔开。为了确保星期与月份不被混淆，week前面通常会加上一个字母 W 。datetime-local 与之前描述过的 datetime 作用基本相同，唯一不同之处是不需要表明时区。 日期和时间datetime：目前，很多浏览器都不支持datetime这个类型。故没效果 本地日期和时间datetime-local： 日期date： 时间time： 月份month： 星期week： 显示效果 日期和时间datetime：目前，很多浏览器都不支持datetime这个类型。故没效果 本地日期和时间datetime-local： 日期date： 时间time： 月份month： 星期week： 使用meter显示度量 标签定义已知范围或分数值内的标量测量。也被称为 gauge（尺度）。例子：磁盘用量、查询结果的相关性，等等。注释： 标签虽说也可标记进度条，但并不应用于指示进度（在进度条中）。如果标记进度条，请使用 标签。 十分之三或 显示效果 十分之三或 用progress显示任务进程 progress 元素被作用于展示一个任务的完成度，典型的例子是用户文件上传或下载。 举例来说，设计10个 checkbox类型的 input元素，当它们全部被激活时，进度条将显示到100%。 Please activate all the checkboxes Progress: 元素 progress的初始值为0，最大值为10.当 input元素被激活时，就会调用 updateProgress()函数，函数内容如下： function updateProgress(){ var pb=document.getElementById(\"pb\"); var ip=document.getElementsByTagName(\"input\"); var cnt=0; for(var i=0;i 变量 ip包括了一个包含所有输入元素的节点列表(NodeList)。for循环测试每一个元素的当前状态，若其被激活(checked==true),计数器变量cnt将增加1.同时，progress元素值将被设成计数器值。 用output进行计算 output 元素用于显示各种表单元素的内容或脚本执行结果，它的作用只是用于显示输出。最常用的例子是电子商务网站的购物车。通过可选的 for属性，你可以决定将哪些字段添加到计算机中。执行运算需要提供一个或更多的相对应输入字段的 id。 举例来说，3种不同商品购物车：为了在 output元素中及时更新每次数量变化，使用表单的 oninput 事件： ProductPrice(US$)Quantity Keyboard39.50 Mouse26.30 Monitor264.50 Your shopping cart contains items.Total price: US$ function updateSum(){ var ips = document.getElementsByTagName(\"input\"); var sum = 0; var prods = 0; for (var i=0;i0){ sum +=cnt*Number(document.getElementById( ips[i].name+\"Price\").innerHTML); prods +=cnt; } } document.getElementById(\"sumProd\").value=prods; document.getElementById(\"sum\").value=sum; } 我们运用JavaScript的 Number()函数将相关列的 innerHTML值转换为数字，并根据它直接从表格中的到商品价格，input字段也用这个方法取值(ips[i].value)。如果略过这个步骤的话，JavaScript会直接将字符串加入计算，这样可能导致无法得到正确的结果，计算结果将被赋值给 output 元素的 value 属性。 客户端表单验证 自动校验 通过对元素使用 required、pattern、min、max和 step等属性以及新增的 input类型，可实现在表单提交时进行自动校验。前面有介绍过， 下面仅举一个简单的执行自动校验的示例。 姓名： 年龄： 手机号码： 显式校验：check Validity()方法进行校验 check Validity()返回一个布尔值，为表单中所有的元素或某个元素的内容无效时，返回 false值，否则返回 true。我们可以通过编写JavaScript代码调用该方法，以将校验结果显示出来，所以又称该方法为“显式校验方法”。 function check(){ var psw=document.getElementById(\"psw\"); if(psw.checkValidity()) alert(\"密码输入正确\"); else alert(\"密码输入错误，请再输一次\"); return false; } 密码： 上述代码对密码输入有效性进行显式校验，分别将校验结果以警告对话框的形式展现。 取消校验 有时需要把表单中已填写好的数据暂存一下，以便将来继续填写，即不管数据是否有效，取消表单的有效性校验。取消表单校验的常用方法有两种：一种是为元素设置 novalidate属性；另一种是对提交按钮设置formnovalidate属性。第一种方式将关闭整个表单的校验，不管提交什么按钮都将不进行校验。第二种方式则由指定的提交按钮来关闭表单的输入校验，只有当用户通过指定了fornvalidate属性的按钮提交表单时才会关闭表单的输入校验。 方法一： 方法二： 自定义校验错误提示信息 使用setCustomValidity()自定义错误提示信息，可用于检测两次密码输入是否一致： function check(){ var psw1=document.getElementById(\"password1\"); var psw2=document.getElementById(\"password2\"); if(psw1.value!==psw2.value) psw2.setCustomValidity(\"密码和确定密码不一致\"); return false; } 密码： 确认密码： MathML 拖放 地理定位 Web 存储 Web SQL 应用程序缓存 Web Workers SSE WebSocket "},"Frontend/HTML/Canvas.html":{"url":"Frontend/HTML/Canvas.html","title":"Canvas","keywords":"","body":"Canvas "},"Frontend/HTML/svg.html":{"url":"Frontend/HTML/svg.html","title":"内联 SVG","keywords":"","body":"SVG SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，它在2003年1月14日成为W3C推荐标准。 什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用于定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG 是万维网联盟的标准 SVG 与 DOM 和 XSL 之类的 W3C 标准是一个整体 SVG优势 与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于： SVG 图像可通过文本编辑器来创建和修改 SVG 图像可被搜索、索引、脚本化或压缩 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 使用方式 可在浏览器直接打开 在HTML中的使用 SVG 文件可通过以下标签嵌入 HTML 文档：, , 和。SVG的代码可以直接嵌入到HTML页面中，或直接链接到SVG文件 , , 标签嵌入 标签 优势 缺点 标签 所有主要浏览器都支持，并允许使用脚本 不推荐在HTML4和XHTML中使用（但在HTML5允许） 标签 所有主要浏览器都支持，并支持HTML4，XHTML和HTML5标准 不允许使用脚本 标签 所有主要浏览器都支持，并允许使用脚本 不推荐在HTML4和XHTML中使用（但在HTML5允许） 直接在HTML嵌入SVG代码 @[把 SVG 直接嵌入 HTML 页面]{../../demo/demo.html?demoname=html5_svg_demo} ../../images/home/html5.png 使用标签 使用img和或者bject等标签直接引用svg。这种方法的缺点主要在于要求每个图标都单独保存成一个SVG文件，使用时也是单独请求的，增加了HTTP请求 链接到svg文件查看svg 在css中使用 .container{ background: white url(img/demo.svg) repeat; } SVG 与 Canvas两者间的区别 SVG 是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较 下表列出了 canvas 与 SVG 之间的一些不同之处。 CanvasSVG依赖分辨率不支持事件处理器弱的文本渲染能力能够以.png或.jpg格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序（比如谷歌地图）复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）不适合游戏应用 更多教程 @[SVG 详解（二）基本概念]{https://blog.csdn.net/qq_25243451/article/details/79792832} ../../images/home/html5.png @[SVG 详解（三）基础语法]{https://blog.csdn.net/qq_25243451/article/details/80012696} ../../images/home/html5.png @[SVG 详解（四）其他常用标签]{https://blog.csdn.net/qq_25243451/article/details/80044681} ../../images/home/html5.png @[菜鸟 SVG 教程]{https://www.runoob.com/svg/svg-tutorial.html} "},"Frontend/CSS/":{"url":"Frontend/CSS/","title":"CSS","keywords":"","body":"CSS层叠样式表 CSS 指层叠样式表 (Cascading Style Sheets) DIV+CSS详解 在CSS布局方式中,DIV是这种布局方式的核心对象,我们的页面排版不再依赖于表格. 仅从DIV的使用上说,做一个简单的布局只需要两样东西:DIV与CSS.因此我们称这种布局方式为 DIV + CSS 布局。 DIV：布局容器标签 div 是XHTML中指定的,专门用于布局设计的容器标签。用于存放html 元素，文字，图片，视频的元素。内容样式由CSS指定。 CSS：层叠样式表 CSS（Cascading Style Sheet，层叠样式表）是一种格式化网页的标准方式，是用于控制网页样式并允许样式信息与网页内容分离的一种技术。 DIV+CSS的优势 符合 W3C标准，微软等公司均为 W3C支持者。 能够对网页的布局、字体、颜色、背景等图文效果实现更加精确的控制,调整更加方便,现在很多网站均使用DIV+CSS框架模式,更加印证DIV+CSS是大势所趋 将格式和结构分离，有利于格式的重用及网页的修改维护，在团队开发中更容易分工合作而减少相互关联性 CSS的极大优势表现在简介的代码，制作体积更小，下载更快，节省大量带宽，而且众所周知，搜索引擎喜欢简洁的代码。 利用CSS样式表，可以将站点上的所有网页都只指向同一个CSS文件，可以实现许多网页同时更新。 什么是W3C标准？W3C标准不是一个标准，而是一系列标准的集合，包含三部分的标准：结构标准、表现标准和动作标准。与结构标准对应的代表语言是xHTML，与表现标准对应的代表语言是CSS，与动作标准对应的代表语言是JavaScript。 CSS语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:CSS声明总是以分号(;)结束，声明总以大括号({})括起来: 选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 CSS注释： CSS注释以 /* 开始, 以 */ 结束。为了让CSS可读性更强，你可以每行只描述一个属性: /*这是个注释*/ p { text-align:center; color:black; /*这是另一个注释*/ /*font-family:arial;*/ } CSS的应用和引入方式 【内嵌式】：在HTML文档内部，将CSS代码卸载标记之间，并需要采用标记进行声明 p{color:red;} 【内联式】：选择你想控制的HTML标签，给它添加style属性，注意这种方式的引入CSS，是不需要写选择器的 【链接式】：在实际网站建设中，链接式CSS用法是最常用效果最好的。 新建一个以css为后缀的文件。在里面写入css。 在需要用到该css的HTML内部的标记中加入link标签，href属性指明外部CSS文件的路径。 【导入式】：与链接式的用法基本相同，区别在于语法和使用方法上略有不用。 @import url(css/index.css); CSS选择符 通配选择符 * 星号选择器将匹配页面里的每一个元素，但我建议你永远不要再生产代码中使用它。它给浏览器带来大量不必要的负担。 *{margin:0; padding:0;} 标签选择符 标签选择符（也叫类型选择符）：也就是把html标签名作为选择符。 ul { list-style:none; } img{ width: 100%;} id选择符 给所需样式标签自定义id名.然后在css文件内写上#自定义id名{CSS样式} #IDname {width: 960px; margin: auto; } [!danger] 每个id名都必须不同，应该慎重使用ID选择器。 类选择符（class） 自定义class名,使用方法:在css文件内写上.class名{css样式} .className {border-color: blue; font-size:16px;} [!danger] 一个标签可以用多个class名,一个class名可以供多个标签使用。 群组选择符 同时控制多个标签。标签名用,隔开 a,p,span{} 组合选择符 我们还可以通过标签名,id名,class名混搭的方式来选择，添加样式 div .p {} /*表示div标签下的所有class为p的标签。*/ div,#a {} /*表示id为a的标签和所有的div标签。*/ 关系选择符 选择符 名称 描述 版本 英文名 E F 包含选择符 选择所有被E元素包含的F元素。 CSS1 (Descendant combinator)这个也有叫后代选择器的 E>F 子选择符 选择所有作为E元素的子元素F。 CSS2 (Child combinator) E+F 相邻选择符 选择紧贴在E元素之后F元素。 CSS2 (Adjacent sibling combinator) E~F 兄弟选择符 选择E元素所有兄弟元素F。 CSS3 (General sibling combinator) 伪类选择符 不是所有的标签都能使用伪类选择符,在此处我们只讲a标签的伪类选择符 a:link {color: #FF0000; text-decoration: none} 未访问的链接 a:visited {color: #00FF00; text-decoration: none} 已访问的链接 a:hover {color: #FF00FF; text-decoration: underline} 鼠标在链接上 a:active {color: #0000FF; text-decoration: underline} 激活链接 [!danger] 以上的a标签伪类你可以写1个或者写多个。但是一定要按照顺序写，否则会出问题！ 选择符 版本 描述 E:link CSS1 设置超链接a在未被访问前的样式。 E:visited CSS1 设置超链接a在其链接地址已被访问过时的样式。 E:hover CSS1/2 设置元素在其鼠标悬停时的样式。 E:active CSS1/2 设置元素在被用户激活(在鼠标点击与释放之间发生的事件)时的样式。 E:focus CSS1/2 设置元素在成为输入焦点(该元素的onfocus事件发生)时的样式。 E:lang(fr) CSS2 匹配使用特殊语言的E元素。很少用 E:not(s) CSS3 匹配不含有s选择符的元素E。 E:root CSS3 匹配E元素在文档的根元素。常指html元素 E:first-child CSS2 匹配父元素的第一个子元素E。 E:last-child CSS3 匹配父元素的最后一个子元素E。 E:only-child CSS3 匹配父元素仅有的一个子元素E。 E:nth-child(n) CSS3 匹配父元素的第n个子元素E。 E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。 E:first-of-type CSS3 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type CSS3 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type CSS3 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n) CSS3 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) CSS3 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty CSS3 匹配没有任何子元素（包括text节点）的元素E。 E:checked CSS3 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled CSS3 匹配用户界面上处于可用状态的元素E。 E:disabled CSS3 匹配用户界面上处于禁用状态的元素E。 E:target CSS3 匹配相关URL指向的E元素。 first-child与first-of-type的区别：举例来说 第一个子元素 第二个子元素 第三个子元素 第四个子元素 p:first-child 匹配到的是p元素,因为p元素是div的第一个子元素； h1:first-child 匹配不到任何元素，因为在这里h1是div的第二个子元素，而不是第一个； span:first-child 匹配不到任何元素，因为在这里两个span元素都不是div的第一个子元素； p:first-of-type 匹配到的是p元素,因为p是div的所有为p的子元素中的第一个，事实上这里也只有一个为p的子元素； h1:first-of-type 匹配到的是h1元素，因为h1是div的所有为h1的子元素中的第一个，事实上这里也只有一个为h1的子元素； span:first-of-type 匹配到的是第三个子元素span。这里div有两个为span的子元素，匹配到的是第一个。 所以，通过以上两个例子可以得出结论： :first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。 :first-of-type 匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。 [!danger] 当然这些元素的范围都是属于同一级的，也就是同辈的。同样类型的选择器:last-child和:last-of-type、:nth-child(n)和:nth-of-type(n)也可以这样去理解。 属性选择符 选择符 版本 描述 E[att] CSS2 选择具有att属性的E元素。 E[att=\"val\"] CSS2 选择具有att属性且属性值等于val的E元素。 E[att~=\"val\"] CSS2 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=\"val\"] CSS3 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=\"val\"] CSS3 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=\"val\"] CSS3 选择具有att属性且属性值为包含val的字符串的E元素。 E[att|=\"val\"] CSS2 选择具有att属性且属性值为以val开头并用连接符\"-\"分隔的字符串的E元素。 伪对象选择符 选择符 版本 描述 E:first-letter/E::first-letter CSS1/3 设置对象内的第一个字符的样式。 E:first-line/E::first-line CSS1/3 设置对象内的第一行的样式。 E:before/E::before CSS2/3 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/E::after CSS2/3 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder CSS3 设置对象文字占位符的样式。 E::selection CSS3 设置对象被选择时的颜色。 [!danger] CSS3的语法改成:: ,原本CSS1是: ,故一般直接用两个冒号为妥。如果为了兼容IE浏览器的话，就用一个冒号。 举例：input::-webkit-input-placeholder {color: green;} 30个你必须记住的CSS选择符 CSS的冲突(即优先级) CSS本身的设置可以同时应用多个样式在同一个元素，此时样式之间可能出现冲突而达不到用户所想要的效果。 解决CSS冲突的优先级规则： CSS层叠样式表引入方法的优先级：内联式>内嵌式>链接式>导入式 在多个外部样式中，后出现的样式的优先级高于先出现的样式，也就是俗称的覆盖 在样式中，选择器的优先级：ID样式>class样式>标记样式（以权重比喻：id的权重为100，class的权重为10,标签名的权重为1） 在样式后面加一个!important，例如这样：.abc {background:#fff !improtant;} 这个样式的优先级就会默认提升到顶级，全局样式就无法影响到它了。 [!danger] !important要写在分号的前面 优先级： 就近原则（离代码越近，优先级越高） 选择范围越小，优先级越高。细化CSS，通过多加父元素的选择符一层层包住，缩小选择范围 样式继承 继承是指我们设置上级(父级)的CSS样式，上级（父级）及以下的子级（下级）都具有此属性。一般只有文字文本具有继承特性，如文字大小、文字加粗、文字颜色、字体等。但注意有一些css样式是不具有继承性的。如border:1px solid red; 举例： 如果你不知道自己想做什么该做什么，那你什么都做不好。 说明： 我设置上级(父级：p)的文字颜色为红色，而子级(span)未设置文字颜色，但是文字具有继承特性，所以子级文字内容依然是红色。 假如设置父级文字颜色样式后，其多个子级因继承而与父级相同，若有些子级颜色不想与父级相同，这个时候只需对对应子级设置需要颜色即可。 [!danger] 还有一个权值比较特殊--继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 继承好处：可以只设置上级的CSS样式表属性，子级（下级）不用设置，都有此CSS属性，可以减少CSS代码，便于维护。 CSS中可以和不可以继承的属性 CSS选择器命名及常用命名 规范的命名也是Web标准中的重要一项，标准的命名可以使代码更加易读，而且利于搜索引擎搜索，比如定义了两个div，一个 id 命名为“div1”，另外一个命名为“News”，肯定第二个比较易读，而且搜索引擎抓取率要高，在团队合作中还可以大大提高工作效率。为了达到这种效果我们就要规范化命名（语义化命名）！ 关于CSS命名法，和其他的程序命名差不多，主要有三种：骆驼命名法，帕斯卡命名法，匈牙利命名法。看他们的名字挺不好理解的，不要被吓到了，其实很容易，不信的话继续往下看~ 骆驼命名法 说到骆驼大家肯定会想到它那明显的特征，背部的隆起，一高一低的，我们的命名也要这样一高一低，怎么才能这样，就用大小写字母呗~，大写的英文就相当于骆驼背部的凸起，小写的就是凹下去的地方了，但是这个也是有规则的，就是第一个字母要小写，后面的词的第一个字母就要用大写，如下：#headerBlock 如果第二个单词后面还有单词呢？那就是下面这种情况，.navMenuRedButton 也就是说，无论几个单词凑一块，后面所有单词癿首字母都要大写。 帕斯卡命名法 这种命名法同样也是大小写字母混编而成，和骆驼命名法很像，但和骆驼命名法有一点区别，就是所有单词的首字母都要大写，当然也包括第一个单词，如下：#HeaderBlock.NavMenuRedButton题外话，如果说“骆驼命名法”是单峰驼的话，那么“帕斯卡命名法”就是双峰驼了~ 匈牙利命名法 匈牙利命名法，是需要在名称前面加上一个或多个小写字母作为前缀，来让名称更加好认，更容易理解，比如：#head_navigation.red_navMenuButton 以上三种，前两种（骆驼命名法、帕斯卡命名法）在命名CSS选择器的时候比较常用，当然这三种命名法可以混合使用，另需要遵守一个原则“容易理解，方便协同工作”就OK了，或者说”即使不懂代码的人看了代码也知道这块起什么作用”，没有必要强调是那种命名法，根据个人喜好使用就行。 页面模块的常用命名 头：header 导航：nav 菜单：menu 友情链接：friendlink 页面外围包裹：wrapper 子导航：subnav 子菜单：submenu 下载：download 页面主体：main 广告：banner 侧栏：sidebar 小技巧：tips 内容：content 标志：logo 栏目：column 滚动：scroll 页脚：footer 搜索：search 热点：hot 上一个：prev 版权：copyright 登录条：loginbar 新闻：news 下一个：next CSS常用属性 [!Tip|label: 温馨提醒] 关于CSS属性个人建议查看手册更加详细方便，我这里就几种常用属性进行分类并简单取几个常用属性值做下笔记 css样式的书写顺序 定位属性：position display float left top right bottom overflow clear z-index 自身属性：width height padding border margin background 字体样式：font-style font-variant font-weight font-size/line-height font-family color 文本属性：text-align vertical-align text-wrap text-transform text-indent text-decoration letter-spacing word-spacing white-space text-overflow css3中新增属性：content box-shadow border-radius transform…… 字体样式 字体的缩写,写法是font:font-style font-variant font-weight font-size/line-height font-family，一定要按照顺序来写 font属性 描述 属性值(说明) font-style 字体样式 normal(正常);italic(斜体);oblique(倾斜的字体样式) font-variant 字母(字体偏小)全大写或正常 normal(正常);small-caps(小型的大写字母); font-weight 字体粗细 normal(正常);bold(粗体);bolder(特粗);lighter(细体);直接用数字表示（数值100-900） font-size 字体大小 px、em、rem line-height 字体行高 可以用长度px; 百分比（基于字体的高度尺寸）; 用数值(乘积因子)指定行高 font-family 字体系列 指定文本使用某个字体或字体序列，值用单引号包起来,默认是宋体.下面举例说明下 font-family举例说明： body{font-family:helvetica,verdana,sans-serif;} 按优先顺序排列。以逗号隔开。如上字体定义，假设你电脑上没有helvetica字体，但有verdana，这时将会以verdana显示你的文字。 @font-face嵌入字体 @font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。 基本语法： @font-face { font-family : 自定义字体名称; src : url(字体文件在服务器上的相对或绝对路径) format(字体类型); } 举例： @font-face {/*该写法是兼容所有的浏览器*/ font-family : bgg; src: url('fonts/fontawesome-webfont.eot'), /* IE9+ */ url('fonts/fontawesome-webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('fonts/fontawesome-webfont.woff') format('woff'), /* chrome、firefox */ url('fonts/fontawesome-webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari,Android, iOS 4.2+*/ url('fonts/fontawesome-webfont.svg') format('svg'); /* iOS 4.1+ */ } p{ font-family: bgg } 文本样式 text属性 描述 属性值(说明) text-indent 文本缩进 值是以em为单位的数值,1em等于一个字的宽度. text-align 文本水平对齐 left(左对齐);center(居中对齐);right(右对齐);justify(两端对齐) vertical-align 文本垂直对齐 middle(父元素的中部);top(与行中最高元素的顶端对齐);text-top(与父元素字体的顶端对齐);还有其他见手册 letter-spacing 文字间距 normal(正常);以px为单位的数值 word-wrap 文本换行 normal(允许内容顶开或溢出);break-word(内容将在边界内换行。如果需要，单词内部允许断行) text-decoration 下划线控制 none(没有下划线,默认);underline(下划线);blink;overline(上划线);line-through(删除线) text-transform 文本的大小写 capitalize(首字母大写);uppercase(转换成大写);lowercase(转换成小写); color 文本颜色 下面单独说明 文本颜色 color 颜色名称 16种基本色为aqua,black,blue,fuchsia,gray,green,lime,maroon,navy,olive,purple,red,silver,tealwhite,and yellow. 16进制（hex）色彩控制（6位数），其格式为 #336699。支持某些hex值的快捷计数法。比如， #336699可以被称为 #369。 RGB值 RGB的数值范围从0到255，R代表红色，G代表绿色，B代表蓝色。举例：{ color: rgb(51,204,0) } 列表样式 list-style(ul) list-style-image:url(\"./dot.gif\"); 图片式符号，选择图像作为列表项的引导符号 list-style-position：列表符号位置, outside（默认值，列表与符号贴近）; inside（列表缩进，与符号相离） list-style-type：符号类型（这里列举几种常用的，若需要日文平假片假什么的可以查手册） 值 描述 值 描述 值 描述 none 无标记 disc 默认。实心圆 circle 空心圆 square 实心方块 decimal 数字 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-alpha 小写英文字母 upper-alpha 大写英文字母 lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) 背景样式 background 背景样式的缩写,写法是{background: background-color background-image background-repeat background-attachment background-position;}{background: 背景色 背景图片 背景平铺方式 背景图像是否固定或者随着页面的其余部分滚动 背景定位} 要按照顺序来。举例background:#F00 url(header_bg.gif) no-repeat fixed left top; background属性 描述 属性值(说明) background-color 背景颜色 同上面文本颜色color相同;transparent(透明背景) background-image 背景图片 backgroung-image:url(图片文件路径); background-repeat 背景图像是否及如何重复 repeat(全部平铺,默认);no-repeat(不平铺);repeat-x(横向平铺);repeat-y(纵向平铺);round(背景图像自动缩放直到适应且填充满整个容器);space(背景图像以相同的间距平铺且填充满整个容器或某个方向) background-attachment 背景图像是否固定或者随着页面的其余部分滚动 scroll(默认值。背景图像会随着页面其余部分的滚动而移动);fixed(当页面的其余部分滚动时，背景图像不会移动); background-position 背景图像的起始位置 水平(left;right;center)+垂直(top;center;bottom)(如果仅指定一个关键字，其他值将会是\"center\",举例：background-position: left center;其中第二个center可以省略);x% y%(水平位置%+垂直%,左上角是0％0％,右下角是100％100％。如果仅指定了一个值，其他值将是50％。默认值为：0％0％);xpos ypos(单位可以是像素（0px0px）或任何其他 CSS单位。如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions) background-size 背景大小 auto(自动，默认以图片大小);px或百分比(若只设置一个值，则第二个值会被设置为 \"auto\");cover(将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。);contain(把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。但是不超出容器);100px 100%(宽高比例改变); background-origin 相对于什么位置来定位 padding-box(背景从边框之后开始,默认);border-box(背景图从边框开始);content-box(背景从内容开始) [!Tip|label: 注释] 如果背景图像的 background-attachment 属性为 \"fixed\"，则该属性没有效果。 边框样式 border 边框线的缩写：{border:border-width border-style border-color;} 举例：四边边框相同：{border:1px solid #00F};若想单独一条边的话，哪个方向的自己挑：{border-[left||right||top||bottom]:border-width border-style border-color;} border-style(边框样式): none(不加边框线,默认); hidden(隐藏边框线); dotted(点状虚线); dashed(线状虚线,常用); solid(实线,常用); double(双实线); groove(浅色实线); ridge(深浅色实线); inset(左上深右下浅的实线); outset(左上浅右下深的实线) border-width(边框宽度): 值是以px为单位的数值 border-color(边框颜色): 值是颜色的英文单词或者十六进制的颜色 轮廓outline 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。轮廓（outline）属性指定元素轮廓的样式、颜色和宽度。用法同border一样。 盒子模型(Box Model) 所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。在网页设计中常用的属性名：content(内容)，padding(填充)，border(边框)，margin(边界), CSS盒子模式都具备这些属性。下面的图片说明了盒子模型(Box Model)： 说明： html 元素都可以看成一个盒子 盒子模型的参照物不一样，则使用的css属性不一样。比如：两个div左右并排时，从div1的角度看，是margin-right，从div2看，则是margin-left。 如果你不希望破坏外观，则尽量使用margin布局，因为padding可能会改变盒子的大小（相当于这个盒子有弹性），margin如果过大，盒子内容被挤到盒子外边去，但盒子本身没有变化。 margin、padding width元素的宽度,值有两种,第一种是弹性宽度,值用百分比表示,第二种是固定宽度,值用以px为单位的数值表示. height元素的高度,值有两种,第一种是弹性高度,值用百分比表示,第二种是固定高度,值用以px为单位的数值表示. margin设置外边距，即区块与周围元素之间或元素与元素之间的间距，它包括了 left||right||top||bottom ，分别设定各个方向对象之间的间距缩写：{margin:margin-top margin-right margin-bottom margin-left;}按照顺时针的顺序 {margin:100px(上) 90px(右) 30px(下) 90px(左);} {margin:100px(上) 90px(左右相等90px) 30px(下);} {margin:100px(上下100px) 90px(左右90px);} {margin:100px(上下左右都为100px);} 可惜的是，上下边距相等，左右不相等是没有缩写的。若想方便调试建议还是四个参数都写上吧，哈哈 padding设置内边距，即区块边框与内容之间的间距，同样包括 left||right||top||bottom ，分别设定各个方向的填充距离缩写或者用法什么的基本都与margin类似 有一个值auto,意思是自动。也有居中的效果元素居中的写法是{margin:100px(上边距) auto 90px(下边距);}或者{margin:100px(上下边距相等) auto;} W3C盒子模型和IE盒子模型 盒模型一共有两种模式，一种是标准模式(W3C盒子模型)，另一种就是怪异模式(IE盒子模型)。 从上图可以看到W3C盒子模型的范围包括margin、border、padding、content，再看看content的宽度width和高度height，可以看出content部分不包含其他部分。 从上图可以看到IE盒子模型的范围也包括margin、border、padding、content，再看看content的宽度width和高度height，可以看出和标准W3C盒子模型不同的是：IE盒子模型的content部分包含了border和pading。 浏览器的兼容性问题那应该选择哪种盒子模型呢？当然是“标准W3C盒子模型”了。怎么样才算是选择了“标准W3C盒子模型”呢？很简单，就是在网页的顶部加上DOCTYPE声明。如果不加 DOCTYPE声明，那么各个浏览器会根据自己的行为去理解网页，即IE浏览器会采用IE盒子模型去解释你的盒子，而FF(Firefox)等会采用标准W3C盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。反之，如果加上了DOCTYPE声明，那么所有浏览器都会采用标准W3C盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 CSS3的box-sizing属性 box-sizing语法：box-sizing：content-box 或者 border-box; 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式:元素的总宽度 = 宽度 + 左padding + 右padding + 左border + 右border + 左margin + 右margin元素的总高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距 当设置为box-sizing:border-box时，将采用怪异模式解析计算； 元素的总宽度= width + margin(左右)（即width已经包含了padding和border值） 块状元素和行内元素 在用CSS布局页面的时候，我们会将HTML标签分成两种，块状元素和行内元素（行内元素也叫内联元素） 块状元素 特点不管内容有多少，它要换行，同时沾满整行。块元素可以放文本、行内元素和块元素，宽度(width)高度(height)起作用。常用的块状元素有： 、、...、、、、、、 、、、、、、 行内元素 特点是只占内容的宽度，默认不会换行，行内元素一般放文本或者其它的行内元素，但宽度(width)高度(height)不起作用。常用的内联元素有： 、、、、、、、、、、、、、、、、 、、、、、、、、、、、 行内块状元素 行内块状元素：就是同时具有行内元素、块状元素的特点。 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 ,标签就是这种行内块状标签。 对比如下 块状元素 行内元素 行内块状元素 是否允许其他元素同处一行 no yes yes width和height是否起作用 yes no yes display属性 值 描述 none 隐藏对象,不保留空间。与visibility属性的hidden值不同,visibility仍会保留空间 inline 指定对象为内联元素。 block 指定对象为块元素。 list-item 指定对象为列表项目。 inline-block 指定对象为内联块元素。（CSS2） table 指定对象作为块元素级的表格。类同于html标签（CSS2） inline-table 指定对象作为内联元素级的表格。类同于html标签（CSS2） table-caption 指定对象作为表格标题。类同于html标签（CSS2） table-cell 指定对象作为表格单元格。类同于html标签（CSS2） table-row 指定对象作为表格行。类同于html标签（CSS2） table-row-group 指定对象作为表格行组。类同于html标签（CSS2） table-column 指定对象作为表格列。类同于html标签（CSS2） table-column-group 指定对象作为表格列组显示。类同于html标签（CSS2） table-header-group 指定对象作为表格标题组。类同于html标签（CSS2） table-footer-group 指定对象作为表格脚注组。类同于html标签（CSS2） Display(显示) 与 Visibility（可见性） 隐藏元素 - display:none或visibility:hidden隐藏一个元素可以通过把display属性设置为\"none\"，或把visibility属性设置为\"hidden\"。但是请注意，这两种方法会产生不同的结果。visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 块状元素和行内元素的转换 如果我们希望一个元素按照块状元素方式显示，则给该元素添加样式display:block; 如果我们希望一个元素按照行内元素方式显示，则给该元素添加样式display:inline; 如果我们希望一个元素按照行内块状元素元素方式显示，则给该元素添加样式display:inline-block; 浮动float CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。Float（浮动），往往是用于图像，但它在布局时一样非常有用。 小白的话可以通过阅读以下两篇文章进行对浮动float的详细了解CSS浮动(float,clear)详细教程w3school CSS 浮动 元素怎样浮动元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。如果图像是右浮动，下面的文本流将环绕在它左边： css解决浮动，清除浮动方法 尽量少用浮动，容易出现副作用，需要清除浮动才行。 从上图可以看出，由于两个黑色盒子产生了浮动，导致红色盒子不能撑开，那么相应的红色盒子的样式也不能显示出来，比如： 背景不能显示 边框不能撑开 margin,padding设置值不能正确显示 清除浮动清除浮动的几种方法 个人推荐使用\"伪元素after\"清除浮动 .clearfix:after {content:\".\"; display:block; height:0; visibility:hidden; clear:both; } .clearfix { *zoom:1; } 文档流 CSS核心内容——流流：在网页设计中就是指元素（标签）的排列方式。 文本流：顾名思义，就是文字，段落什么的。文本流是相对于文子段落讲的 文档流：个人觉得文档流的翻译容易误导人，没看过原版的我竟然拿\"document flow\"去问了度娘，然后被鄙视……（哈哈，开个小玩笑）。原文是\"normal flow\"，不明白为什么会被翻译成文档流，也有人叫普通流、正常流，指语言文本从左到右，从上到下显示，这是传统HTML文档的文本布局。 标准文档流：简称为\"标准流\"，是指在不使用其他与排位和定位相关的特殊CSS规则时各种页面元素默认的排列规则。也就是默认的块级元素和行内元素的排列方式。在一个页面中如果没有出现特殊的排列方式如定位什么的，排在前面的元素（标签）在内容前面出现，排在后面的元素（标签）在内容后面出现。依次排序，整个页面如同河流和它的支流，所以称为\"标准流\"。 脱离文档流：也叫\"非标准流\"，当某个元素（标签）脱离了标准流【比如因为浮动或者定位之类】排列，我们统称为非标准流排列。 文档流和文本流的区别 元素浮动之后，会让它跳出文档流，也就是说当它后面还有元素时，其他元素会无视它所占据了的区域，直接在它身下布局。但是文字却会认同浮动元素所占据的区域，围绕它布局，也就是没有拖出文本流。总结来说：浮动后脱离文档流，但是没有脱离文本流。 但是绝对定位后，元素既会脱离文档流也会脱离文本流。那么后面元素的文本就不会再认同它的区域位置，会直接在它后面布局，不会在环绕。 当然你可以使用z-index来让底部的元素到上面来，类似于一个图层的概念。 定位position position 属性指定了元素的定位类型。position 属性的五个值： 属性值 描述 static 静态定位，HTML元素的默认值，即没有定位，遵循正常的文档流对象。网页里任一元素的默认position属性值均是static。静态定位的元素不会受到 top,bottom,left,right影响。 relative 相对定位，相对定位，相对于自身原来的位置，但是原来的位置仍然保留。 absolute 绝对定位，相对于最近的非标准流定位，原来的位置消失，被后边的位置所顶替。将被赋予此定位方法的对象从文档流中拖出，使用left,right,top,bottom等属性相对于其最接近的一个有定位设置的父级对象进行绝对定位，如果对象的父级没有设置定位属性，即还是遵循HTML定位规则的，则依据body对象左上角作为参考进行定位。绝对定位对象可层叠，层叠顺序可通过z-index属性控制，z-index值为无单位的整数，大的在最上面，可以有负值。 fixed 固定定位，它和绝对定位类似，只是以浏览器窗口为基准进行定位，也就是当拖动浏览器窗口的滚动条时，依然保持对象位置不变。 sticky 粘性定位，基于用户的滚动位置来定位,它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 [!danger] 尽量不使用该属性值，Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。 阅读这篇文章详细了解position：CSS 定位详解 @[综合实例见证定位的魅力position]{../../demo/demo.html?demoname=position} ../../images/home/css.png 其他CSS属性 布局overflow overflow 属性用于控制内容溢出元素框时显示的方式。 值 描述 visible 默认值。当层内的内容超出层所能容纳的范围时，显示层大小及内容 hidden 当层内的内容超出层所能容纳的范围时，隐藏超出层大小的内容 scroll 不管层内容是否超出层所能容纳的范围，层总是显示滚动条 auto 如果层内容超出层所能容纳的范围，才会显示滚动条 [!danger] overflow 属性只工作于指定高度的块元素上 鼠标属性cursor cursor属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状。常用的是cursor:pointer;(一只手)下面表格描述了各个cursor效果，将鼠标移动到各个属性值单词上面，可以看到鼠标指针发生变化： 属性值 描述 属性值 描述 属性值 描述 default 默认光标（通常是一个箭头） auto 默认。浏览器设置的光标。 pointer 小手掌 crosshair 十字线 move 方向移动十字型 wait 一只表或沙漏 w-resize 向左箭头 n-resize 向上箭头 nw-resize 左上箭头 e-resize 向右箭头 s-resize 向下箭头 se-resize 右下箭头 ne-resize 右上箭头 sw-resize 左下箭头 help 一个问号或一个气球 "},"Frontend/CSS/CSS3.html":{"url":"Frontend/CSS/CSS3.html","title":"CSS3","keywords":"","body":"CSS3 CSS3 是最新的 CSS 标准。CSS3 是 CSS 规范的最新版本，在 CSS2.1 的基础上增加了很多强大的新功能，以帮助开发人员解决一些实际面临的问题，并且不再需要非语义标签、复杂的 JavaScript 脚本以及图片。例如，CSS3 支持圆角、多背景、透明度、阴影、动画、图表等功能。 CSS3 简介 CSS3 规范是分模块的 CSS1 和 CSS2.1 都是单一的规范，其中 CSS1 主要定义了网页对象的基本样式，如字体、颜色、背景、边框等，CSS2 添加了高级概念，如浮动、定位、高级选择器（如子选择器、相邻选择器和通用选择器等）。 CSS3 被划分成了多个模块，每个模块都有自己的规范，这样做的好处是： 整个 CSS3 的规范发布不会因为部分存在争论而影响其他模块的推进。 对于浏览器来说，可以根据需要，决定哪些 CSS 功能被支持。 对于 W3C 制定者而言，可以根据需要进行针对性的更新，从而使一个整体的规范更加灵活，并能够及时修订，这样更容易扩展新的技术特定。 CSS3 新特性 CSS3 规范并不是完全另起炉灶，它集成了 CSS2.1 的部分内容，但在其基础上进行了很多的增补与修订。与 CSS1、CSS2 相比，CSS3 进行了革命性的升级，而不仅限于局部功能的修订和完善，尽管浏览器对 CSS3 诸多新特性的支持还不是很完善，但是它依然让用户看到了未来网页样式的发展方向和使命。CSS3 的新特性非常多，这里简单列举被浏览器广泛支持的实用特性。 完善选择器 完善视觉效果 完善背景效果 完善盒模型 增强背景功能 增加阴影效果 增加多列布局与弹性盒模型布局 完善 Web 字体和 Web Font 图标 新增圆角与边框功能 增加变形操作 增加动画和交互效果 完善媒体特性与 Responsive 布局 CSS3浏览器兼容性一览表 CSS3 属性支持情况：完全支持 CSS3 属性的浏览器有 Chrome 和 Safari，而且不管是 Mac 平台还是 Windows 平台全支持。CSS3 选择器支持情况：除了 IE 家族和 Firefox3，其他几乎全部支持，Chrome、Safari、Firefox 3.6、Opera 10.5 最好。 各主流浏览器都定义了私有属性，以便让用户体验 CSS3 的新特性。例如， Webkit 类型浏览器（如 Safari、Chrome）的私有属性是以-webkit-前缀开始， Gecko 类型的浏览器（如 Firefox）的私有属性是以-moz-前缀开始， Konqueror 类型的浏览器的私有属性是以-khtml-前缀开始， Opera 浏览器的私有属性是以-o-前缀开始， 而 Internet Explorer 浏览器的私有属性是以-ms-前缀开始（目前只有 IE 8+ 支持-ms-前缀）。 @[附录：主流浏览器对CSS属性支持的详细列表]{http://c.biancheng.net/view/1281.html} ../../images/home/css3.png CSS3 圆角border-radius CSS3圆角只需设置一个属性：border-radius（含义是\"边框半径\"）。你为这个属性提供一个值，就能同时设置四个圆角的半径。所有合法的CSS度量值都可以使用：em、px、百分比等等。border-radius:50px;这条语句同时将每个圆角的\"水平半径\"和\"垂直半径\"都设置为50px。 CSS3 border-radius - 指定每个圆角 border-radius可以同时设置1到4个值指定每个圆角。（类似margin与padding属性） 1个值，四个圆角值相同 2个值，第一个值为左上角与右下角，第二个值为右上角与左下角 3个值，第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 4个值，则依次对应左上角、右上角、右下角、左下角(顺时针顺序)。 border-radius: 10px 20px 30px 40px / 5px 10px 15px 20px;也可以分别设置每个角的垂直半径和水平半径,用斜杠隔开，第一个参数表示左上角开始顺时针的水平半径，第二个参数表示左上角开始顺时针的垂直半径 CSS3提供四个单独的属性 对应四个角border-top-left-radius border-bottom-right-radiusborder-top-right-radius border-bottom-left-radius这四个属性都可以同时设置1到2个值。如果设置1个值，表示水平半径与垂直半径相等。如果设置2个值，第一个值表示水平半径，第二个值表示垂直半径。 常用圆角图形 圆 .circle {width:100px; height:100px; border-radius: 50%;background: gold;} 半圆 .semi_circle { width:200px; height:100px; /* 高度是宽度的一半 */ background-color:#000; border-radius:100px 100px 0 0; /* 左上和右上至少为height值 */ } 扇形 .sector {width:0; height:0; border:50px solid gray; border-radius:50px; border-right-color:red;} 椭圆 .ellipse {width:200px; height:100px; background: blue; border-radius:100px/50px;} @[常用圆角图形]{../../demo/demo.html?demoname=border-radius} ../../images/css/border-radius.png \"rect\" CSS3 背景background CSS3 中包含几个新的背景属性(background-image, background-size, background-origin, background-clip)，提供更大背景元素控制，更是可以使用多重背景图像。 CSS3 background-clip属性 CSS3中background-clip背景剪裁属性是从指定位置开始绘制。 语法：background-clip: border-box|padding-box|content-box; 值 说明 border-box 默认值。背景绘制在边框方框内（剪切成边框方框）。 padding-box 背景绘制在衬距方框内（剪切成衬距方框）。 content-box 背景绘制在内容方框内（剪切成内容方框）。 @[background-clip属性]{../../demo/demo.html?demoname=background-clip} ../../images/home/css3.png CSS3 多重背景(multiple backgrounds) 多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。 语法缩写如下： { background: [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],... } 可以把上面的缩写拆解成以下形式： { background-image:url1,url2,...,urlN; background-repeat : repeat1,repeat2,...,repeatN; backround-position : position1,position2,...,positionN; background-size : size1,size2,...,sizeN; background-attachment : attachment1,attachment2,...,attachmentN; background-clip : clip1,clip2,...,clipN; background-origin : origin1,origin2,...,originN; background-color : color; } [!danger] 用逗号隔开每组 background 的缩写值； 如果有 size 值，需要紧跟 position 并且用 \"/\" 隔开； 如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。 background-color 只能设置一个。 代码示例： #example1 { background-image: url(../../images/css/img_flwr.png), url(../../images/css/paper.png); background-position: right bottom, left top; background-repeat: no-repeat, repeat; padding: 15px; } Lorem Ipsum Dolor Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. 显示效果如下： Lorem Ipsum Dolor Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. CSS3 渐变gradients CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 渐变的含义与组成 含义：两种或多种颜色之间平滑过渡的效果 组成：由色标来组成（色标：1.颜色 2.颜色出现的位置） CSS3 线性渐变（Linear Gradients） 为了创建一个线性渐变，你必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。 语法 { background-image: linear-gradient(direction, color-stop1, color-stop2, ...); } direction: 指定渐变的方向或角度，属性值为 方向的关键词或角度值 角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 [!warning] 但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。 角度 direction 作用 0deg/360deg to top 从下向上填充渐变 90deg to right 从左向右填充渐变 180deg to bottom (默认值)从上向下填充渐变 270deg to left 从右向左填充渐变 45deg to top right 左下角到右上角填充渐变 135deg to bottom right 左上角到右下角填充渐变 225deg to bottom left 右上角到左下角填充渐变 315deg to top left 右下角到左上角填充渐变 @[CSS3 线性渐变（Linear Gradients）实例]{../../demo/demo.html?demoname=linear-gradient} ../../images/home/css3.png color-stop: 色标，标识一种颜色，以及出现的位置 第一个参数省略时，默认为“180deg”，等同于“to bottom”。第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。颜色值后面可以追加百分比，表示这个颜色要占总背景颜色面积的百分比。不加百分比即为平均分布。 举例说明： div { background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); } 该div元素线性渐变，方向是to right，即从左向右填充渐变，7 个颜色结点（均匀分布），效果类似彩虹 div { background-image:linear-gradient(to right, red 10%,blue 80%,green 90%); } 该div元素线性渐变，方向是to right，即从左向右填充渐变，10%的时候是红色，80%的时候是蓝色，90%的时候是绿色，加百分比不均匀分布 显示效果如下： 7 个颜色结点（均匀分布） 3 个颜色结点（不均匀分布） CSS3 径向渐变（Radial Gradients） 径向渐变由它的中心定义。为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 语法 { background-image: radial-gradient(shape size at position, start-color, ..., last-color); } shape：设置形状 shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 size：设置半径 size 参数定义了渐变的大小。它可以是具体值 px，也可以是以下四个关键字： closest-side: 半径为从圆心到最近边 closest-corner: 半径为从圆心到最近角 farthest-side: 半径为从圆心到最远边 farthest-corner: 半径为从圆心到最远角(默认) @[深入理解CSS径向渐变radial-gradient]{https://www.cnblogs.com/xiaohuochai/p/5383285.html} ../../images/home/css3.png position：圆心的位置 可用数值、百分比、或者 关键字(left/center/right/top/center/bottom)表示 [!tip] 该参数可以省略，如果省略的话，那么圆心默认就在元素的中间位置处 举例说明： div { background-image:radial-gradient(100px at 0px 0px,red 0%,blue 50%,green 100%); } 该div元素径向渐变，圆的半径是100px，圆心在元素的左上角，0%的时候是红色，50%的时候是蓝色，100%的时候是绿色 显示效果如下： 径向渐变，圆的半径是100px，圆心在元素的左上角，0%的时候是红色，50%的时候是蓝色，100%的时候是绿色 CSS3 重复渐变（Repeating Gradients） 语法 /* 重复线性渐变 */ { background-image: repeating-linear-gradient(direction, color-stop1, color-stop2, ...); } /* 重复径向渐变 */ { background-image: repeating-radial-gradient(shape size at position, start-color, ..., last-color); } 重复渐变除了在线性渐变或者径向渐变前加repeating-之外，其他用法和属性均与普通线性渐变和径向渐变相同 渐变效果图对比 /* 线性渐变 */ { background-image: linear-gradient(to top,red 0%,blue 50%,green 100%); } /* 径向渐变 */ { background-image:radial-gradient(100px at center center,red 0%,blue 50%,green 100%); } /* 重复线性渐变 */ { background-image:repeating-linear-gradient(red, yellow 10%, green 20%); } /* 重复径向渐变 */ { background-image: repeating-radial-gradient(5px at 0px 0px,red 0%,blue 50%,green 100%); } { background-image:repeating-radial-gradient(40px at center center,red 0%,blue 50%,green 100%); } 显示效果如下： 线性渐变 径向渐变 重复线性渐变 重复径向渐变 重复径向渐变 @[css3 渐变效果图对比]{../../demo/demo.html?demoname=css3-gradient} ../../images/home/css3.png "},"Frontend/CSS/example.html":{"url":"Frontend/CSS/example.html","title":"EXAMPLE","keywords":"","body":"CSS EXAMPLE 字体单行或双行 更加详细请看：http://www.daqianduan.com/6179.html /*单行*/ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: normal; /*双行*/ /*因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；*/ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; background简写方式图片铺满元素的几种写法 1. 裁剪铺满背景,不拉伸图片形状。不要求全部展示图片的可以使用 { background: url('../../images/home/css3.png') no-repeat center/cover; } 2. 不裁剪铺满背景,不拉伸图片形状, 图片规格和屏幕一致可以使用这种方式 { background: url('../../images/home/css3.png') no-repeat center/contain; } 3. 不裁剪铺满背景, 拉伸图片形状。让整个图片全部填满元素 { background: url('../../images/home/css3.png') no-repeat center/100% 100%; } "},"Js/JavaScript/":{"url":"Js/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 很容易学习。 JS 简介 javascript因为兼容于ECMA标准，因此也称为ECMAScript。 JavaScript作为一种脚本语言，已经被广泛地应用于Web页面当中，通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。除此之外，也可以用于控制cookies以及基于Node.js技术进行服务器端编程。 发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。1997年，在ECMA(欧洲计算机制造商协会)的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。 javascript是甲骨文公司的注册商标，完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型（DOM）和浏览器对象模型（BOM）。 ECMAScript : 核心 (描述了javascript组成语言的语法和基本对象) DOM : 文档对象模型 (描述处理网页内容的方法和接口) BOM : 浏览器对象模型 (描述与浏览器进行交互的方法和接口) Javascript与Java的比较 JavaScript和Java除了在名字上有一点类似，以及JavaScript语法源自于Java外，两者其实存在很大的不同，主要体现在以下几点。 JavaScript由浏览器解释执行，Java程序则是编译执行。 JavaScript是一种基于对象的脚本语言；Java则是一种面向对象的编程语言。 JavaScript是弱类型语言，可以不声明变量而直接使用变量；Java是强制类型语言，变量在使用前必须先声明。 强/弱类型是指类型检查的严格程度的。语言有无类型，弱类型和强类型三种。无类型的不检查，甚至不区分指令和数据。弱类型的检查很弱，仅能严格的区分指令和数据。强类型的则严格的在编译期进行检查。 JAVA是强类型语言：因此每个变量和对象都必须具有声明类型。javascript是弱类型语言：因此它可以不先定义类理和对象、或用var定义所有变量 JS 用法 HTML 中的脚本必须位于 与 标签之间。脚本可被放置在 HTML 页面的 和 部分中。也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。如需使用外部文件，请在 标签的 \"src\" 属性中设置该 .js 文件 大小写敏感（严格区分字母大小写） 执行顺序：JavaScript程序按照在HTML文件中出现的顺序逐行执行。如果需要在整个HTML文件中执行（如函数、全局变量等），最好将其放在 HTML文件的...标记中。某些代码，比如函数体内的代码，不会被立即执行，只有当所在的函数被其他程序调用时，该代码才会被执行。 与Java语言不同，JavaScript并不要求必须以分号;作为语句的结束标记。JavaScript会自动将该行代码的结尾作为语句的结尾。 JS 字面量/常量 在编程语言中，一般固定值称为字面量，如 3.14。 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e):3.14； 字符串（String）字面量 可以使用单引号或双引号:'John Doe'； 表达式字面量 用于计算：5 + 6； 数组（Array）字面量 定义一个数组：[1,2]； 对象（Object）字面量 定义一个对象：{a: 1, b: 2}； 函数（Function）字面量 定义一个函数：function fun(a) {return a}。 JS 关键字 JavaScript 关键字用于标识要执行的操作。关键字是不能作为变量名和函数名使用的。比如 var 关键字告诉浏览器创建一个新的变量。以下是 JavaScript 中最重要的保留字（按字母顺序）： abstract boolean break byte case catch char class const continue debugger default delete do double else enum export extends false final finally float for function goto if implements import in instanceof int interface let long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with JS 变量 在编程语言中，变量用于存储数据值。JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值。 变量的命名规则 第一个字符必须是字母或者 $ 和 _ 符号开头; 变量名中不能包含空格或标点符号或加号减号等符号（$ 除外); 变量名称对大小写敏感（y 和 Y 是不同的变量）; 不能使用保留字、关键字; 为了让变量名有更好的可读性，可以在变量名中适当的插入下划线分隔，如：var my_mood = 'happy' 变量的声明和赋值 可以用 var 同时声明多个变量：var a,b,c 可以声明的同时对其赋值，即为初始化：var a=1,b=2,c=3 如果只是声明了变量而未对其赋值，则其值默认为 undefinedvar sex = male; console.log(male); // male is not defined 将male当做一个变量 如果声明同一个变量，而且其已经有一个初始值的话，那么重新声明就相当于对变量重新赋值。 变量也可以不使用var作声明而直接使用，这样虽然简单但不易发现变量各方面的错误。 [!tip] 一个好的编程习惯是，在代码开始处，统一对需要的变量进行声明。 JavaScript 注释 // 单行注释/* */ 多行注释，注意：多行注释不能互相嵌套 Chrome 浏览器中执行 JavaScript 我们在 Chrome 浏览器中可以通过按下 F12 按钮或者右击页面，选择\"检查\"来开启开发者工具。 打开开发者工具后，我们可以在 Console 窗口调试 JavaScript代码。 我们也可以在 Chrome 浏览器中创建一个脚本来执行，在开发者工具中点击 Sources 面板，选择 Snippets 选项卡，在导航器中右击鼠标， 然后选择 Creat new snippet 来新建一个脚本文件： JS 数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。引用数据类型：对象(Object)、数组(Array)、函数(Function)。 [!Warning|label: 注意] Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 JS 拥有动态类型 JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型： var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = \"John\"; // 现在 x 为字符串 JS 字符串（String） 字符串由零个或多个Unicode字符构成，可以是引号中的任意文本。您可以使用单引号或双引号。单引号中可以含有单引号或双引号，只要不匹配包围字符串的引号即可；但是单包单或双包双时必须进行转义，用\\隔开。 var str = 'I like \"JavaScript\"'; // 单包双 var str = \"I like 'JavaScript'\"; // 双包单 var str = 'I like \\'JavaScript\\''; // 单包单 var str = \"I like \\\"JavaScript\\\"\"; // 双包双 [!note] javascript中的字符串是不可变的。一旦字符串被创建，就永远无法改变它。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，可以通过+运算符连接其他字符串来创建一个新字符串。举例：var lang = \"java\"; lang = lang + \"script\"; => 'javascript'以上代码的实际过程是：首先创建一个能够容纳10个字符的新字符串，然后在这个字符串中填充'java'和'script'， 最后一步是销毁原来的字符串'java'和'script'，因为这两个字符串已经没用了。 JS 数字（Number） JavaScript 只有一种数字类型。数字可以带小数点，也可以不带： var x1=34.00; //使用小数点来写 var x2=34; //不使用小数点来写 极大或极小的数字可以通过科学（指数）计数法来书写： var y=123e5; // 12300000 var z=123e-5; // 0.00123 JS 布尔（Boolean） 布尔（逻辑）只能有两个值：true 或 false。 [!danger] 在Number()方法中空字符串和空白字符串都转换为0，而在Boolean方法中，空字符串\"\"转换为 false，而空白字符串\" \"转换为 true。与字符串不同，不要把布尔值用引号括起来。布尔值 false 与 字符串 \"false\"是两回事。 JS 数组（Array） 我们的变量一般都只能存储一个内容，所以它其实是一个单一的容器。我们的数组一般可以存一个或者是多个值，所以数组是一个大的容器。 组成部分 数组其实是由多个(键-值)所组成的一个多容器，数组的索引 默认是从0开始的，所以第一个项目是 [0]，第二个是 [1]，以此类推。 JS 对象（Object） 在 JavaScript中，几乎所有的事物都是对象。对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person={firstname:\"John\", lastname:\"Doe\", id:5566}; 上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。空格和折行无关紧要。声明可横跨多行： var person={ firstname : \"John\", lastname : \"Doe\", id : 5566 }; 对象属性有两种寻址方式： name=person.lastname; name=person[\"lastname\"]; 特殊数据类型 转义字符 在javascript字符串，反斜线 \\ 有着特殊的用途，反斜线符号后加一个字符，就不表示它们的字面含义，用来表示一些特殊字符，称为转义字符。 \\0 空字节 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 换页符 \\\\ 反斜杠,对自身转义 \\' 单引号 \\\" 双引号 \\xnn 以十六进制nn表示一个字符(n为0-f)，如\\x41表示A\\unnnn 以十六进制nnnn表示一个Unicode字符(n为0-f)，如\\u03a3表示希腊字符ε [!tip] 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略，如 '\\a' => 'a' null 在JavaScript中null表示\"什么都没有，为空值\"。null是一个只有一个值的特殊类型。表示一个空对象引用。var person = null; // 你可以设置为null来清空对象。注意：null 不等同于空的字符串（\"\"）或0 undefined 在JavaScript中, undefined是一个没有设置值的变量，表示变量还没有赋值（如var a;）， 或者赋予一个不存在的属性值（如var a=String.notProperty;）。typeof一个没有值的变量会返回undefined。var person = undefined; // 你可以设置为undefined来清空对象。 undefined和null的区别 null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。undefined表示值未定义。 大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 typeof undefined // undefined typeof null // object null === undefined // false null == undefined // true NaN 特殊类型的数字常量NaN，即“非数字”。当在程序中由于某种原因发生计算错误后，将产生一个没有意义的数字，此时JavaScript返回的数字值就是NaN。 声明变量类型 当您声明新变量时，可以使用关键词 new 来声明其类型： var carname = new String; var x = new Number; var y = new Boolean; var cars = new Array; var person = new Object; [!note] JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。 JS 数据类型转换 typeof 操作符 你可以使用 typeof 操作符来检测变量的数据类型。 typeof \"John\" // 返回 string typeof 3.14 // 返回 number typeof false // 返回 boolean typeof [1,2,3,4] // 返回 object typeof {name:'John', age:34} // 返回 object [!tip] 在JavaScript中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object。NaN 的数据类型是 number; 日期(Date)的数据类型为 object; null 的数据类型是 object。 constructor 属性 constructor 属性返回所有 JavaScript 变量的构造函数。 \"John\".constructor // 返回函数 String() { [native code] } (3.14).constructor // 返回函数 Number() { [native code] } false.constructor // 返回函数 Boolean() { [native code] } [1,2,3,4].constructor // 返回函数 Array() { [native code] } {name:'John', age:34}.constructor // 返回函数 Object() { [native code] } new Date().constructor // 返回函数 Date() { [native code] } function() {}.constructor // 返回函数 Function(){ [native code] } 你可以使用 constructor 属性来查看对象是否为数组 (包含字符串 \"Array\")，也可以使用 constructor 属性来查看对象是否为日期 (包含字符串 \"Date\"): @[constructor 属性实例]{../../demo/demo.html?demoname=constructor} ../../images/home/javascript.png JS 数据类型转换 强制转换 强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值 1. Number函数：强制转换成数值 Number(\"324\") // 324 Number(\"324abc\") // NaN Number(\"\") // 0 Number(false) // 0 Number(undefined) // NaN Number(null) // 0 2. String函数：强制转换成字符串 String(123) // \"123\" String(\"abc\") // \"abc\" String(true) // \"true\" String(undefined) // \"undefined\" String(null) // \"null\" 3. Boolean函数：强制转换成布尔值 Boolean(undefined) // false Boolean(null) // false Boolean(0) // false Boolean(NaN) // false Boolean('') // false 转换函数 toString()：转换为字符串 parseInt()：转换成整数 parseFloat()：转换成浮点数 更多更新转换函数在 [高级章节]，待完善。 自动转换 当遇到以下几种情况，JavaScript会自动转换数据类型： 不同类型的数据进行互相运算； 对非布尔值类型的数据求布尔值; 对非数值类型的数据使用一元运算符（即“+”和“-”）。 1. 自动转换为布尔值 除了以下六个值，其他都是自动转为true：undefined, null, -0, +0, NaN, ''(空字符串) if (!undefined && !null && !0 && !NaN && !''){ console.log('true'); } // true 2. 自动转换为字符串 字符串的自动转换，主要发生在加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。 '5' + 1 // '51' 1 + 2 + '5' // '35' '5' + true // \"5true\" '5' + {} // \"5[object Object]\" '5' + [] // \"5\" '5' + function (){} // \"5function (){}\" '5' + undefined // \"5undefined\" '5' + null // \"5null\" 3. 自动转换为数值 除了加法运算符有可能把运算子转为字符串，其他运算符都会把两侧的运算子自动转成数值。 '5' - '2' // 3 '5' * '2' // 10 true - 1 // 0 false - 1 // -1 '1' - 1 // 0 '5'*[] // 0 false/'5' // 0 'abc'-1 // NaN 下表展示了使用不同的数值转换为数字(Number), 字符串(String), 布尔值(Boolean): 原始值 转换为数字 转换为字符串 转换为布尔值 false 0 \"false\" false true 1 \"true\" true 0 0 \"0\" false 1 1 \"1\" true \"0\" 0 \"0\" true \"000\" 0 \"000\" true \"1\" 1 \"1\" true NaN NaN \"NaN\" false Infinity Infinity \"Infinity\" true -Infinity -Infinity \"-Infinity\" true \"\" 0 \"\" false \"20\" 20 \"20\" true \"Hqbook\" NaN \"Hqbook\" true [ ] 0 \"\" true [20] 20 \"20\" true [10,20] NaN \"10,20\" true [\"Hqbook\"] NaN \"Hqbook\" true [\"Hqbook\",\"Google\"] NaN \"Hqbook,Google\" true function(){} NaN \"function(){}\" true { } NaN \"[object Object]\" true null 0 \"null\" false undefined NaN \"undefined\" false @[javascript数据类型转换]{https://www.css88.com/archives/5199} ../../images/home/javascript.png JS 运算符 算术运算符 +（加）; -（减）; *（乘）; /（除）; %（求模、取余数）[(前面正得正，负得负)：10.5 % 3; // 1.5];无非就是数学的四则运算，过于简单就不做详细介绍，不懂就回去问你们小学数学老师 ++（自增） 后加加：i++先赋值后自增加1 前加加：++i先自增加1后赋值 --（自减）：同++（自增）类似 // 如果 y = 5 x = ++y; // x=6 y=6 x = y++; // x=5 y=6 x = --y; // x=4 y=4 x = y--; // x=5 y=4 赋值运算符 = 将右边表达式的值付给左边的变量+= 给当前这个变量增加多少 a += 3;等同于（a = a+3）同理：-=(加), *=(减), /=(乘), %=(求模) 还有&=(与运算) a &= b, 相当于a = a&b同理：|=(或运算), ^= (异运算) 字符串的 + 运算符（类似拼接） 当+存在于变量与字符串中间位置的时候就代表是拼接或者连接的作用，而 += 运算符则用于连接两个字符串，并将结果赋给第一个字符串。 var a = \"23\", b = 1; a+b // 231 这个例子说明 如果不是同种类型的话 那么`+`代表的是拼接的意思 a-b // 22 这个例子说明 除了+ 这种特殊的运算方式以外 即使是不同类型那么也能够进行运算 var name = \"JavaScript\"; name+=\" book\"; // JavaScript book 比较运算符 >（大于）, （小于）, >=（大于或等于）, （小于或等于）,==（等于）, !=（不等于），===（全等于、绝对等于)，!== (不全等于，不绝对等于，值和类型有一个不相等，或两个都不相等) 在js里面一个等号=代表赋值，两个等号==才代表判断是否相等（判断数值相等，当数值0和1和布尔值做比较会将数值转换成布尔值）, 三个等于号===代表全等于（判断数值且类型相等） null==false =》 false | undefined == false =》 false | null == undefined =》 truenull === undefined =》 false | null == 0 =》 false | null === 0 =》 false0 == false =》 true | 1 == true =》 true | 4 == true =》 false假如两个变量进行比较，它的全等于为假，那么它的不全等于为真 =》 true 逻辑运算符 &&（与）：一假全假；(x 1) 为 true ||（或）：一真则真；(x==5 || y==5) 为 false !（非）：假变真，真变假。!(x==y) 为 true 运算符优先级 JavaScript中的运算符优先级是一套规则。该规则在计算表达式时控制运算符执行的顺序。具有较高优先级的运算符先于较低优先级的运算符执行。例如，乘法的执行先于加法。 下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。 运算符 描述 .``[]``() 字段访问、数组下标、函数调用以及表达式分组 ++ -- - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取余 + - + 加法、减法、字符串连接 >> >>> 移位 > >= instanceof 小于、小于等于、大于、大于等于、instanceof == != === !== 等于、不等于、全等于、不全等于 & 按位与 ^ 按位异或 | 按位或 && 逻辑与 || 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 JS 条件语句 JS 流程控制 就是程序代码执行顺序，通过规定的语句让程序代码有条件的按照一定的方式执行。 三大流程控制结构： 顺序结构：按照书写顺序来执行，是程序中最基本的流程结构。 条件结构（分支结构）：根据给定的条件有选择的执行相应的语句，分支控制有三种：①单分支，②双分支，③多分支，④嵌套分支。 循环结构：在给定的条件满足的情况下，反复的执行同一段代码。 条件语句 if 语句 - (单分支)，只有当指定条件为 true 时，使用该语句来执行代码。 if (condition) { // 当条件为 true 时执行的代码，如果只包含一条语句，那么可以省略{}，一般最好不要省略 } if...else 语句 - (双分支)，当条件为 true 时执行代码，当条件为 false 时执行其他代码 if (condition) { // 当条件为 true 时执行的代码 } else { // 当条件不为 true 时执行的代码 } if...else if...else 语句 - (多分支)，如果某个条件成立，则后续就不再继续判断了，直接结束整个多分支。 if (condition1) { // 当条件 1 为 true 时执行的代码 } else if (condition2) { // 当条件 2 为 true 时执行的代码 } else { // 当条件 1 和 条件 2 都不为 true 时执行的代码 } [!danger] 一旦找到一个满足条件的入口，执行完毕后，就直接结束整个多分支，所以需要用对条件语句。比如： 10需要写成 10; var a = 5; if (a > 1) { // 条件满足，执行这里的代码 } else if (a > 3) { // 这个入口条件虽然也满足条件，但是上面入口已经满足，所以这里不会执行。 } if...if... 语句 - (嵌套分支)，如果某个条件成立，则后续就不再继续判断了，直接结束整个多分支。 if (condition1) { // 当条件 1 为 true 时执行的代码 if (condition2) { // 当条件1和条件2 都为 true 时执行的代码 } } else { // 当条件 1 不为 true 时执行的代码 } switch 语句 当有很多种选项的时候，switch比if else使用更方便。switch适合处理判断分支较多的情况下(代码可读性好)，而if适合处理判断分支较少的情况下(反之代码可读性差，容易出现漏判或重复判断)。尽管if括号内也支持常量、枚举但也是有前提的那就是常量或枚举必须要显式给出相应的数值，而switch则不必。 switch('条件表达式') { case '常量1': '语句'; break; case '常量2': '语句'; break; // … case '常量n': '语句'; break; default: '语句'; } case有几个都行，default可以没有。当case所有条件都不满足的时候，则default。default并不一定要在最后。 case后面一般是常量（能作用在int和比int范围下的数字型数据类型，int,short,char,byte。long和String类型是不行的。）而不同于if else的条件判断，switch不是if的替代品。编译时会对switch进行优化，根据case标签后面的常量值，生成跳转表，只经过少数次数的比较，就可以跳到对应标签下面。所以，标签也是不能重复的。如果允许变量，switch只能退化成跟一连串的if else, 对于一个数据也只能从头到尾地进行比较，也就失去了switch的意义。跳转表和逐个比较，这两种方式的复杂度差很多。 break是中断跳转语句，表示在完成相应的case标号规定的操作之后，不继续执行switch语句的剩余部分而直接跳出switch语句之外，继而执行switch结构后面的第一条语句，如果不在switch结构的case中使用break语句。程序就会接着执行下面的语句。 default用于处理所有switch结构的非法操作。当表达式的值与任何一个case都不匹配时，则执行default语句。 举例：我们将上面用if语句做的例子改用switch语句来判断学生分数的水平。 var score = prompt('你的成绩是?'); // 因为`case`后面是常量，我们又不至于把`0~100`的每个分数都判断一遍吧，所以可以进行取整判断 // 在上面的代码中，`break`作用是跳出整个`switch`语句，如果没有`break`停止语句，那么当输入`100`后将每种结果都弹窗一次，不信你试试 switch(parseInt(score/10)){ case 10: alert('非常优秀'); break; case 9: alert('优秀'); break; case 8: alert('良好'); break; case 7: alert('中等'); break; default: alert('继续努力'); break; } JS 循环语句 循环结构：在给定的条件满足的情况下，反复的执行同一段代码循环结构以下几种：while循环、do while循环、for循环 for - 循环代码块一定的次数 for/in - 循环遍历对象的属性 while - 当指定的条件为 true 时循环指定的代码块 do/while - 同样当指定的条件为 true 时循环指定的代码块 for 循环 for('循环初值'; '循环条件'; '步长') { '循环体语句'; } for 循环的执行顺序 通俗的讲：for(a;b;c){循环体语句}执行顺序：先执行a，再判断b是否为真，若为真，执行循环体，执行c然后再次判断b是否为真，若为真，执行循环体，执行c直到b为假，跳出循环 详情看这里：http://jingyan.baidu.com/article/7f766dafaa6ee04101e1d0e6.html 下面详细介绍for循环一个非常有趣的例子： 打印出【金字塔型】【完整菱形】和【自定义菱形】的思路算法。而且还有很多有趣的例子你们可以网上百度找找，像九九乘法口诀表或者国际象棋等。 @[for循环 金字塔等有趣例子]{https://blog.csdn.net/wenximalong/article/details/8224891} ../../images/home/javascript.png [!danger|label:注意：少用for循环] 要知道，循环计算的话电脑运行会消耗内存资源，为提高性能效率，for循环用的少比较好，2个for循环可以解决就别用3个，虽然可读性降低了，但是性能好。 while 循环 while 循环会在指定条件为真时循环执行代码块。 while('循环条件') { '循环体语句'; } 用一个例子来说明 用while循环计算从1累加到n的总和。接下来就是思路了，思路最重要啊，这个数学不好就。。。首先从1开始加，加2得到一个值，然后加3又得到一个值，循环加，所以 如何确定循环条件表达式，一般我们会用“变量 满足表达式条件应该执行什么循环体语句 如何存放总和 var n = window.prompt(\"请输入一个整数\"); n = parseInt(n); var i = 1; var sum = 0; while(i do while循环 do/while循环是while循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。 do { '循环体语句' } while ('循环条件'); 眼尖的人已经看出来，跟while语句语法颠倒过来差不多，其实也是，因为它用法确实跟while差不多，只不过还是有区别的：while循环是先判断再执行语句。do while循环是先执行，再判断。所以while的循环体里面的语句可能不执行，而do while循环体里面的语句则至少执行一次。 用罚抄作业来通俗讲解的话就是while：上来先问你作业做了没，做了，就不打你（先判断，再执行） do while：上来先打一顿，打完了再问，作业做了吗（先执行，再判断） var i = 10; //【do while循环】 do{ document.write('不管作业，先打再说'); i++; }while(i 这里我已经先将while循环那段注释掉了，你们复制的时候注意，没用到哪段哪段就注释掉，这样效果更明显。可以看到，do while循环体里面的语句先执行一次，所以会浏览器显示出“不管作业，先打再说”，并且打印出 i 的值，i 变成11。接下来我们把【do while循环】那段代码注释，把while循环这段代码清掉注释，然后运行后可以看到，浏览器并没有显示什么东西，只有打印出 i的值为10。 break 和 continue 语句 break 语句用于跳出循环。continue 用于跳过循环中的一个迭代。 break和continue有什么区别break 语句可以立即退出循环;continue 语句只是退出当前循环;看看下面的例子，输出10个数，如果数值为5，break就停止输出。而continue却是不输出5但是后面继续循环输出。 for(var num=1;num with 语句 将代码的作用域设置到一个特定的对象中，先来看一般我们是怎么样输出对象的属性的值的： var box = { name: \"张三\", age: 24, sex: \"男\" }; var n = box.name; var a = box.age; var s = box.sex; document.write(n + \"\"); document.write(a + \"\"); document.write(s); 改用with语句来写： var box={ name: \"张三\", age: 24, sex: \"男\" }; with(box){ var n = name; var a = age; var s = sex; }; document.write(n + \"\"); document.write(a + \"\"); document.write(s); 两个运行的结果是一样的，可以看出with语句的简洁明了，不过在代码的世界里是很难找到真正的完美。js的解释器需要检查with块中的变量是否属于with包含的对象，这将使with语句执行速度大大下降，并且导致js语句很难被优化。所以在以后的高效代码开发中我们应该尽可能的避免使用with语句。 函数 什么是函数？ 函数就是完成某个功能的一组语句，函数由关键字function + 函数名 + 一组参数定义;函数在定义后可以被重复调用，通常将常用的功能写成一个函数，利用函数可以使代码的组织结构更多清晰。Javascript Function无处不在，而且功能强大！通过Javascript函数可以让JS具有面向对象的一些特征，实现封装、继承等，也可以让代码得到复用。但事物都有两面性，Javascript函数有的时候也比较“任性”，你如果不了解它的“性情”，它很可能给你制造出一些意想不到的麻烦（bugs)出来。 基本语法 function functionname(arg0, arg1, '…', 'argN') { '这里是要执行的代码' } 函数就是一段可以反复调用的代码块。函数声明由三部分组成：函数名，函数参数，函数体。整体的构造是function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。当函数体没有使用return关键字返回函数时，函数调用时返回默认的undefined；如果有使用return语句，则返回指定内容。函数最后不用加上冒号。 function say_hello(name,msg) { alert('hello' + name + ':' + msg); } say_hello('david', 'How are you today?'); 使用return语句从函数返回值 function sum (num1, num2){ return num1 + num2; } var s = sum(1, 2); alert(s); 注意事项 位于return语句之后的任何代码都永远不会执行！整个JavaScript并不会停止执行，仅仅是函数。JavaScript将继续执行代码，从调用函数的地方。 在JavaScript中，不一定要指定返回值！ 定义函数的参数时，如果调用函数时没有传进参数，并不会报错，但可以在函数里面判断一下是否有传进参数，例如可以这样判断:if(variable == 'undefined' || variable == null){ variable = '1'; // 可以给他一个默认值 } 函数参数 函数的实参和形参 声明函数时，定义括号内的变量是形参；调用时传入的值是实参。可选形参：(1)实参个数 undefined；(2)可选项必须放在参数列表的末尾，必选项先传入。 默认值:在JavaScript中，函数参数的默认值是undefined。然而，在某些情况下设置不同的默认值是有用的。一般策略是在函数的主体测试参数值是否为undefined，如果是则赋予一个值，如果不是，则返回实际参数传递的值。 function keith(a, b) { (typeof b !== 'undefined') ? b = b: b = 1; return a * b; } console.log(keith(15)); //15 console.log(keith(15, 2)) //30 上面代码中，做了个判断。当在调用时没有传入b参数，则默认为1。 从ECMAScript 6开始，定义了默认参数(default parameters)。使用默认参数，在函数体的检查就不再需要了。 function keith(a, b = 1) { return a * b; } 参数传递方式 函数参数的传递方式有两种，一个是传值传递，一个是传址传递。当函数参数是原始数据类型时（字符串，数值，布尔值），参数的传递方式为传值传递。也就是说，在函数体内修改参数值，不会影响到函数外部。 var a = 1; function keith(num) { num = 5; } keith(a); console.log(a); //1 上面代码中，全局变量a是一个原始类型的值，传入函数keith的方式是传值传递。因此，在函数内部，a的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值。 var arr = [2, 5]; function keith(Arr) { Arr[0] = 3; } keith(arr); console.log(arr[0]); //3 上面代码中，传入函数keith的是参数对象arr的地址。因此，在函数内部修改arr第一个值，会影响到原始值。注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 var arr = [2, 3, 5]; function keith(Arr) { Arr = [1, 2, 3]; } keith(arr); console.log(arr); // [2,3,5] 上面代码中，在函数keith内部，参数对象arr被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（Arr）与实际参数arr存在一个赋值关系。 同名参数 如果有同名参数，则取最后面出现的那个值，如果未提供最后一个参数的值，则取值变成undefined。 function keith(a, a) { return a; } console.log(keith(1, 3)); //3 console.log(keith(1)); //undefined 如果想访问同名参数中的第一个参数，则使用arguments对象。 function keith(a, a) { return arguments[0]; } console.log(keith(2)); // 2 arguments对象 JavaScript 中每个函数内都能访问一个特别变量 arguments。这个变量维护着所有传递到这个函数中的参数列表。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推，通过arguments[n],来访问第n个参数。标识符arguments是指向实参对象的引用。这个对象只有在函数体内部，才可以使用。 可以访问arguments对象的length属性，判断函数调用时到底带几个参数。 function keith(a, b, c) { console.log(arguments[0]); //1 console.log(arguments[2]); //3 console.log(keith.length); //3 fn.length：表示形参个数 console.log(arguments.length); //4 arguments.length：表示实参个数 } keith(1, 2, 3, 4); arguments对象与数组的关系arguments对象不是一个数组（Array）。 尽管在语法上它有数组相关的属性length，但它不从Array.prototype继承，实际上它是一个类数组对象。因此，无法对arguments变量使用标准的数组方法，比如push, pop 或者slice。但是可以使用数组中的length属性。非严格模式下，argument为标识符。严格模式下，argument为保留字。通常使用如下方法把arguments对象转换为数组：var arr = Array.prototype.slice.call(arguments); 如何定义一个函数？ 函数声明 function functionName(parameters) { '执行的代码' } 函数声明后js解析器会优先读取，不会立即执行，会在我们需要的时候调用到。如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 函数表达式，又叫函数字面量 函数表达式可以存储在变量中： var x = function (a, b) { return a * b }; 在函数表达式存储在变量后，变量也可作为一个函数使用：var z = x(4, 3); @[函数声明和函数表达式的区别]{http://www.cnblogs.com/isaboy/p/javascript_function.html} ../../images/home/css3.png 可将调用语句写在函数声明之前。但是在 函数表达式之前调用函数会报错，因为这个时候函数变量值是undefined。 命名函数的函数表达式 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 var keith = function boy(){ console.log(typeof boy); }; console.log(boy); // ReferenceError: boy is not defined keith(); // function 上面代码在函数表达式中，加入了函数名boy。这个boy只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。 Function() 构造函数 函数同样可以通过内置的 JavaScript 函数构造器Function()定义。 var myFunction = new Function(\"a\", \"b\", \"return a * b\"); var x = myFunction(4, 3); 函数的部分属性和方法 name属性 name属性返回紧跟在function关键字之后的那个函数名。 function k1() {}; console.log(k1.name); //'k1' var k2 = function() {}; console.log(k2.name); //'' var k3 = function hello() {}; console.log(k3.name); //'hello' 上面代码中，name属性返回function后面紧跟着的函数名。对于k2来说，返回一个空字符串，注意：匿名函数的name属性总是为空字符串。对于k3来说，返回函数表达式的名字（真正的函数名为k3，hello这个函数名只能在函数内部使用。） length属性 length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。返回的是个数，而不是具体参数。 function keith(a, b, c, d, e) {}; console.log(keith.length) // 5 上面代码定义了空函数keith，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于5。也就是说，当调用时给实参传递了6个参数，length属性会忽略掉一个。 toString()方法 函数的toString方法返回函数的代码本身。 function keith(a, b, c, d, e) { // 这是注释。 } console.log(keith.toString()); //function keith(a, b, c, d, e) { // 这是注释。 } 可以看到，函数内部的注释段也被返回了。 "},"Js/JavaScript/mind_map.html":{"url":"Js/JavaScript/mind_map.html","title":"JS 知识图谱","keywords":"","body":"Javascript 知识图谱 以下学习脑图在各个学习章节里面也有，具体学到相应章节可以仔细研读，本篇只是做个规整。 "}}